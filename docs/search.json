[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CONTROLE ESTATÍSTICO DE QUALIDADE",
    "section": "",
    "text": "Prefácio\nO Controle Estatístico de Qualidade (CEQ) consolidou-se, ao longo do último século, como um dos pilares da moderna gestão da qualidade. Desde as contribuições pioneiras de Walter A. Shewhart, que introduziu os gráficos de controle na década de 1920, até as aplicações contemporâneas em manufatura, saúde, tecnologia da informação e administração pública, o CEQ tornou-se uma ferramenta indispensável para compreender e reduzir a variabilidade dos processos.\nMais do que um conjunto de técnicas, o CEQ representa uma mudança de paradigma: a passagem de uma postura reativa — que atua apenas quando falhas são detectadas — para uma abordagem proativa e preventiva, voltada a monitorar continuamente os processos e identificar causas de variação antes que estas se traduzam em defeitos ou perdas.\nEste projeto nasce da convicção de que a difusão do CEQ deve ir além dos ambientes industriais e alcançar diferentes áreas de conhecimento e prática profissional. Para isso, combinamos o estudo dos fundamentos estatísticos com o uso de ferramentas computacionais modernas, em especial as linguagens R e Python, que tornam possível a aplicação prática em contextos reais de análise de dados.\nNosso objetivo não é apenas apresentar técnicas, mas também estimular uma visão crítica sobre sua utilização, incentivando o leitor a compreender o “porquê” por trás dos métodos. O caminho aqui proposto é duplo: rigor matemático-estatístico aliado a uma postura prática de experimentação com softwares livres, de modo que a teoria encontre aplicação imediata em exemplos concretos.\nAssim, este trabalho pretende contribuir tanto para estudantes quanto para profissionais que buscam aprofundar-se nos métodos do CEQ, oferecendo uma base sólida para a análise, o monitoramento e a melhoria contínua de processos.\n\nEste é um Quarto Book. Para saber mais sobre Quarto Book, visite quarto.org.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "C1_Introduction.html",
    "href": "C1_Introduction.html",
    "title": "1  Introdução ao Controle Estatístico de Qualidade",
    "section": "",
    "text": "1.1 Relação entre Gráficos de Controle e Testes de Hipóteses\nA busca pela qualidade acompanha a história da produção de bens e serviços. Desde os primeiros artesãos, que inspecionavam manualmente suas peças, até os sistemas modernos de manufatura avançada e serviços digitais, sempre houve a necessidade de garantir que o produto final atendesse a requisitos previamente definidos. No entanto, foi apenas no início do século XX que a estatística passou a desempenhar um papel central nesse processo.\nO Controle Estatístico de Qualidade (CEQ) surge como uma metodologia estruturada para compreender, monitorar e melhorar processos por meio de técnicas estatísticas. Seu objetivo central é distinguir a variabilidade natural — inerente a qualquer processo — das causas especiais de variação, que sinalizam problemas ou mudanças não planejadas. Essa distinção, introduzida por Walter A. Shewhart, é a base conceitual dos gráficos de controle, uma das ferramentas mais utilizadas até hoje.\nA aplicação do CEQ traz benefícios que vão além da simples detecção de falhas. Ao proporcionar uma visão clara sobre a estabilidade de um processo, ele permite:\nAo longo das décadas, o CEQ expandiu sua influência. Inicialmente aplicado em linhas de produção industriais, hoje é utilizado em áreas tão diversas quanto saúde pública, administração de serviços, engenharia de software e educação. Essa diversidade de aplicações reflete o caráter universal das ferramentas estatísticas: qualquer processo que gere dados pode ser analisado sob a ótica do controle estatístico.\nNeste projeto, exploraremos tanto os fundamentos matemáticos e estatísticos do CEQ quanto suas aplicações práticas em softwares livres. O uso de R e Python será fundamental para ilustrar, passo a passo, como implementar as técnicas e interpretar seus resultados. Assim, o leitor poderá não apenas compreender a teoria, mas também praticá-la em contextos reais, desenvolvendo autonomia para aplicar o CEQ em sua área de atuação.\nA análise do desempenho de um gráfico de controle está intimamente ligada aos princípios do teste de hipóteses, funcionando como uma ferramenta estatística que realiza uma sequência de testes para monitorar a estabilidade de um processo. Para fins de exemplo, considere que se esteja interessado na média de uma determinada caractéristica de uma variável.\nEssencialmente, a hipótese nula (\\(H_0\\)) postula que o processo está sob controle, com sua média \\(\\mu\\) igual a um valor alvo \\(\\mu_0\\). A estrutura do gráfico reflete diretamente a lógica de um teste: a região entre os Limites de Controle (LIC e LSC) corresponde à área de não rejeição de \\(H_0\\), enquanto qualquer ponto fora desses limites cai na região de rejeição. Assim, quando um ponto amostral se posiciona dentro dos limites, não há evidências para afirmar que o processo saiu do controle.\nAo utilizar essa abordagem, estamos sujeitos a dois tipos de erros estatísticos:\nA habilidade do gráfico em detectar mudanças (como um deslocamento na média para \\(\\mu = \\mu_0 + \\delta\\)) é avaliada pela Curva Característica de Operação (CO), que calcula a probabilidade do Erro Tipo II (\\(\\beta\\)) para diferentes magnitudes de mudança (\\(\\delta\\)) e tamanhos de amostra (\\(n\\)), mantendo um \\(\\alpha\\) fixo.\nApesar das semelhanças, existem diferenças importantes na aplicação de Testes de Hipóteses (TH) e Gráficos de Controle (GC):\nAs causas que levam um processo a sair do controle podem se manifestar de várias formas, mas nem todas se alinham perfeitamente ao modelo de um teste de hipóteses clássico. Por exemplo, uma causa atribuível pode resultar em: 1. Uma mudança permanente na média para um novo valor. 2. Uma mudança temporária, com a média retornando ao estado de controle. 3. Um deslocamento constante ou uma tendência de subida/descida na média.\nÉ importante notar que apenas o primeiro cenário (uma mudança para um novo patamar fixo) corresponde diretamente ao modelo usual de teste de hipóteses que se aprende na estatística básica.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução ao Controle Estatístico de Qualidade</span>"
    ]
  },
  {
    "objectID": "C1_Introduction.html#relação-entre-gráficos-de-controle-e-testes-de-hipóteses",
    "href": "C1_Introduction.html#relação-entre-gráficos-de-controle-e-testes-de-hipóteses",
    "title": "1  Introdução ao Controle Estatístico de Qualidade",
    "section": "",
    "text": "Erro Tipo I (\\(\\alpha\\)): Ocorre quando concluímos que o processo está fora de controle, mas na verdade ele continua estável. É o equivalente a um “alarme falso”.\nErro Tipo II (\\(\\beta\\)): Acontece quando concluímos que o processo está sob controle, quando na verdade ele sofreu uma alteração. Este erro é frequentemente mais custoso para a empresa, pois uma falha real no processo não é detectada.\n\n\n\n\nTH: Geralmente, verifica a validade de uma suposição sobre um parâmetro populacional em um único ponto no tempo (ex: a média da população é igual a \\(\\mu_0\\) ?).\nGC: Seu objetivo principal é monitorar e verificar a estabilidade do processo de forma contínua ao longo do tempo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução ao Controle Estatístico de Qualidade</span>"
    ]
  },
  {
    "objectID": "C1_Introduction.html#sobre-os-softwares-usados",
    "href": "C1_Introduction.html#sobre-os-softwares-usados",
    "title": "1  Introdução ao Controle Estatístico de Qualidade",
    "section": "1.2 Sobre os Softwares Usados",
    "text": "1.2 Sobre os Softwares Usados\n\n1.2.1 Linguagem de Programação R\n\n\n1.2.2 Linguagem de Programação Python",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução ao Controle Estatístico de Qualidade</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html",
    "href": "C2_PlotOfVariables.html",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "",
    "text": "2.1 Introdução\nOs gráficos de controle para variáveis são ferramentas estatísticas desenvolvidas para monitorar características da qualidade que podem ser medidas em escala contínua, como diâmetro, peso, volume, temperatura ou tempo. Diferem dos gráficos para atributos, que se baseiam em classificações qualitativas (conforme/não conforme, defeituoso/não defeituoso), ao permitir uma análise mais detalhada tanto da tendência central quanto da variabilidade do processo.\nA lógica subjacente é simples, mas poderosa: todo processo produtivo apresenta flutuações naturais, chamadas de causas comuns de variação. No entanto, alterações significativas — as chamadas causas especiais — indicam que o processo pode estar fora de controle. Os gráficos para variáveis foram construídos justamente para separar esses dois tipos de variação, permitindo identificar quando uma intervenção é necessária.\nEntre os gráficos mais utilizados destacam-se:\nEsses gráficos compartilham uma estrutura comum: uma linha central (LC) que representa o valor esperado sob controle e dois limites de controle — superior (LSC) e inferior (LIC) — que delimitam a faixa de variação natural do processo. Valores fora dessa faixa, ou padrões não aleatórios dentro dela, são interpretados como indícios de descontrole.\nO uso adequado de gráficos para variáveis depende de decisões fundamentais: o tamanho e a frequência das amostras, a definição de subgrupos racionais e a escolha entre amplitude ou desvio padrão como medida de dispersão. Tais escolhas impactam diretamente a sensibilidade do gráfico em detectar mudanças, assim como o custo de amostragem.\nPor sua capacidade de revelar simultaneamente oscilações na média e na variabilidade, os gráficos de controle para variáveis continuam sendo uma das ferramentas mais robustas e versáteis do Controle Estatístico de Qualidade, sustentando análises confiáveis em diferentes contextos produtivos e de serviços.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#introdução",
    "href": "C2_PlotOfVariables.html#introdução",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "",
    "text": "Gráficos de Médias e Amplitudes (\\(\\bar{X}\\) e \\(R\\)): adequados quando o tamanho da amostra é pequeno (tipicamente \\(n \\leq 10\\)). O gráfico \\(\\bar{X}\\) monitora a média amostral, enquanto o gráfico R acompanha a variabilidade por meio da amplitude.\nGráficos de Médias e Desvios-Padrão (\\(\\bar{X}\\) e \\(S\\)): preferidos quando o tamanho das amostras é maior (\\(n &gt; 10\\)) ou variável, por utilizarem o desvio padrão como medida mais robusta de dispersão.\nGráficos de Medidas Individuais e Amplitudes Móveis (I-MR): aplicáveis quando não há possibilidade de coletar subgrupos de tamanho maior que 1. O gráfico I acompanha as observações individuais, enquanto o MR mede a variação entre observações consecutivas.\n\n\n\n\n\n2.1.1 Constantes Estatísticas Usadas\n\n\n\n\n\n\nFigura 2.1: Constantes Estatísticas usadas no Controle Estatístico de Qualidade para Contrução de Gráficos de Controle.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#gráfico-de-controle-para-barx",
    "href": "C2_PlotOfVariables.html#gráfico-de-controle-para-barx",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.2 Gráfico de Controle para \\(\\bar{X}\\)",
    "text": "2.2 Gráfico de Controle para \\(\\bar{X}\\)\nPara a construção dos Gráfico de Controle de \\(\\bar{X}\\), suponha que a característica de interesse, \\(X\\), tem média \\(\\mu\\) e desvio padrão \\(\\sigma\\), conhecidos. Desta forma, ao retirar uma amostra \\(X_{1}, X_{2}, \\ldots, X_{n}\\) de tamanho \\(n\\), a média amostral é dada por: \\[\\bar{X} = \\dfrac{\\sum_{i=1}^{n} X_{i}}{n}\\]\nPelo Teorema Central do Limite (TCL), sabe-se que \\(\\bar{X}\\) é normalmente distribuído com média \\(\\mu\\) e variância \\(\\sigma^{2}/n\\). Usando os fundamentos de estimação intervalar, temos que o Intervalo de Confiança (IC) de \\(100(1 - \\alpha)\\)% para \\(\\mu\\) é expresso como: \\[\\bar{X} \\pm z_{\\alpha/2} \\sqrt{\\sigma^{2}/n}.\\]\nBaseado nisso, Shewhart propôs, de modo geral, que temos um estimador \\(T\\) de alguma característica de qualidade. A partir desse princípio, a estrutura de um Gráfico de Controle Shewhart é definida por três linhas principais: uma Linha Central (LC), um Limite Superior de Controle (LSC) e um Limite Inferior de Controle (LIC).\nSe considerarmos \\(T\\) como esse estimador, com média \\(\\mu_T\\) e desvio-padrão \\(\\sigma_T\\), os limites são calculados da seguinte forma:\n\\[\n\\text{Limites} = \\begin{cases} \\mu_T - L\\sigma_T, \\quad \\text{se o Limite for Inferior} \\\\ \\mu_T, \\quad \\text{se o Limite for Central} \\\\ \\mu_T + L\\sigma_T, \\quad \\text{se o Limite for Superior} \\end{cases}\n\\tag{2.1}\\]\nNessas fórmulas, \\(L\\) representa a distância dos limites de controle em relação à linha central, expressa em unidades de desvio-padrão. Os limites são determinados com base na média e no desvio-padrão da variável quando o processo está operando isento de causas atribuíveis, ou seja, quando está sob controle estatístico.\nContudo, a escolha do valor de \\(L\\) é uma tarefa fundamental, pois impacta diretamente a sensibilidade do gráfico e as taxas de erro. Existe um trade-off clássico entre os erros tipo I e tipo II:\n\nSe L é grande: Os limites de controle ficam mais afastados da média. Isso diminui a probabilidade de um Erro Tipo I (alarme falso), mas aumenta a de um Erro Tipo II (falhar em detectar um processo fora de controle).\nSe L é pequeno: Os limites ficam mais próximos da média, o que aumenta a sensibilidade a desvios. Consequentemente, a probabilidade de Erro Tipo I sobe, enquanto a de Erro Tipo II diminui.\n\nNos EUA, tornou-se prática padrão utilizar \\(L = 3\\), estabelecendo os chamados “limites de 3 sigmas”. Como mencionado no início, a base para isso vem do Teorema Central do Limite. Com \\(L = 3\\), a probabilidade de um ponto da média amostral cair fora dos limites de controle por puro acaso (Erro Tipo I) é extremamente baixa, calculada como \\(0.0026998\\). Isso significa que, em média, um sinal incorreto de que o processo está fora de controle será gerado apenas a cada 370 pontos amostrais, aproximadamente.\n\n2.2.1 Limites de Probabilidade e de Alerta\n1. Limites de Probabilidade: Uma abordagem alternativa, mais comum no Reino Unido e em partes da Europa Ocidental, é o uso de Limites de Probabilidade. Em vez de fixar \\(L\\), primeiro se especifica a probabilidade de Erro Tipo I (\\(\\alpha\\)) desejada. Por exemplo, se especificarmos um \\(\\alpha = 0,001\\), esperamos um falso alarme a cada 1000 pontos. A partir desse \\(\\alpha\\), determinam-se os valores correspondentes da distribuição normal-padrão (\\(z_{\\alpha/2}\\)) para calcular os limites.\n2. Limites de Alerta (2\\(\\sigma\\)): Para aumentar a sensibilidade do gráfico, alguns analistas sugerem o uso de dois conjuntos de limites:\n\nLimites de Ação (3\\(\\sigma\\)): São os limites de controle tradicionais (LIC e LSC). Quando um ponto cai fora deles, uma ação corretiva é necessária para encontrar a causa atribuível;\nLimites de Alerta (2\\(\\sigma\\)): São limites mais estreitos. Se um ou mais pontos se situam entre os limites de alerta e os de ação, isso serve como um aviso de que o processo pode não estar operando adequadamente, justificando uma maior atenção.\n\nO ponto positivo dessa abordagem é o aumento da sensibilidade para detectar desvios. O ponto negativo, no entanto, é que ela também aumenta o risco de alarmes falsos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#exemplos-computacionais",
    "href": "C2_PlotOfVariables.html#exemplos-computacionais",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.3 Exemplos Computacionais",
    "text": "2.3 Exemplos Computacionais\nSerá apresentados alguns exemplos computacionais de como realizar o gráfico de controle para \\(\\bar{X}\\). A maioria dos dados serão provinientes de simulação para fins didáticos.\n\nR BaseR usando ggplot2Python\n\n\n\n\nCódigo\n# Número de Amostras Selecionadas\nk &lt;- 25\n\n# Tamanho de cada Amostra\nn &lt;- 5\n\n# Simular Dados e Adicionar Ruído aos Dados\nset.seed(42)\nvec.data &lt;- rnorm(k * n, mean = 25, sd = 1.5) + rnorm(k * n, mean = 0, sd = 1.2)\n\n# Organizar a Matriz de Dados\nmatrix.data &lt;- matrix(vec.data, nrow = k, ncol = n, byrow = TRUE)\n\n# Vetor de Médias\nvec.means &lt;- apply(matrix.data, 1, mean)\n\n# Vetor de Desvios\nvec.sds &lt;- apply(matrix.data, 1, sd)\n\n# Estimar Algumas Quantidades\nx.bar &lt;- mean(vec.means)\nx.std &lt;- 1.5\n\n# Construir Limites\nLIC &lt;- x.bar - (3 / sqrt(n)) * x.std # Limite Inferior de Controle\nLC  &lt;- 25                            # Limite Central\nLSC &lt;- x.bar + (3 / sqrt(n)) * x.std # Limite Superior de Controle\n\n# Definir limites do eixo Y para garantir que tudo seja visível\nylim &lt;- c(min(vec.means, LIC) - 7, max(vec.means, LSC) + 7)\n\n# Criar o gráfico principal com pontos e linhas\nplot(x = 1:k, y = vec.means,\n     type = \"b\", # \"b\" para both (pontos e linhas)\n     xlab = \"Amostra\",\n     ylab = \"Medida\",\n     ylim = ylim,\n     pch = 19, # Tipo de ponto (círculo sólido)\n     col = \"black\",\n     font.lab = 2 # Deixa os títulos dos eixos em negrito\n)\n\n# Adicionar as linhas de controle\nabline(h = LIC, col = \"red\", lwd = 2)\nabline(h = LC, col = \"blue\", lwd = 2)\nabline(h = LSC, col = \"red\", lwd = 2)\n\n# Adicionar a legenda\nlegend(\"topright\",\n       legend = c(\n         bquote(LSC == .(round(LSC, 2))),\n         bquote(hat(mu) == .(round(LC, 2))),\n         bquote(LIC == .(round(LIC, 2)))\n       ),\n       col = c(\"red\", \"blue\", \"red\"),\n       lwd = 2,\n       bty = \"solid\" # \"n\" Remove a caixa ao redor da legenda\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nlibrary(ggplot2)\n\n# Número de Amostras Selecionadas\nk &lt;- 25\n\n# Tamanho de cada Amostra\nn &lt;- 5\n\n# Simular Dados e Adicionar Ruído aos Dados\nset.seed(42)\nvec.data &lt;- rnorm(k * n, mean = 25, sd = 1.5) + rnorm(k * n, mean = 0, sd = 1.2)\n\n# Organizar a Matriz de Dados\nmatrix.data &lt;- matrix(vec.data, nrow = k, ncol = n, byrow = T)\n\n# Vetor de Médias\nvec.means &lt;- apply(matrix.data, 1, mean)\n\n# Vetor de Desvios\nvec.sds &lt;- apply(matrix.data, 1, sd)\n\n# Estimar Algumas Quantidades\nx.bar &lt;- mean(vec.means)\nx.std &lt;- 1.5\n\n# Construir Limites\nLIC &lt;- x.bar - (3 / sqrt(n)) * x.std # Limite Inferior de Controle\nLC  &lt;- 25                         # Limite Central\nLSC &lt;- x.bar + (3 / sqrt(n)) * x.std # Limite Superior de Controle\n\n# Construir Gráfico de Controle no ggplot2\nggplot(data = NULL, aes(x = 1:k, y = vec.means)) +\n  geom_point(size = 2) + geom_line() +\n  geom_hline(aes(yintercept = LIC, color = \"LIC\")) +\n  geom_hline(aes(yintercept = LC, color = \"LC\")) +\n  geom_hline(aes(yintercept = LSC, color = \"LSC\")) +\n  scale_color_manual(\n    values = c(\"LIC\" = \"red\", \"LC\" = \"blue\", \"LSC\" = \"red\"),\n    labels = c(\n      bquote(LIC == .(round(LIC, 2))),\n      bquote(mu[0] == .(round(x.bar, 2))),\n      bquote(LSC == .(round(LSC, 2)))\n    )\n  ) +\n  labs(\n    x = \"Amostra\",\n    y = \"Medida\",\n    color = \"Limites\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(\n    axis.title.x = element_text(face = \"bold\"),\n    axis.title.y = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Parâmetros\nk = 25  # Número de Amostras\nn = 5   # Tamanho de cada Amostra\n\n# Simular dados com semente de aleatoriedade para reprodutibilidade\nnp.random.seed(42)\nvec_data = np.random.normal(loc=25, scale=1.5, size=k*n) + np.random.normal(loc=0, scale=1.2, size=k*n)\n\n# Organizar a matriz de dados\nmatrix_data = vec_data.reshape(k, n)\n\n# Vetor de médias (média de cada linha)\nvec_means = matrix_data.mean(axis=1)\n\n# Vetor de desvios (desvio padrão amostral de cada linha, ddof=1)\nvec_sds = matrix_data.std(axis=1, ddof=1)\n\n# Estimar quantidades\nx_bar = vec_means.mean()\nx_std = 1.5\n\n# Construir limites\nlic = x_bar - (3 / np.sqrt(n)) * x_std  # Limite Inferior de Controle\nlc  = 25                               # Limite Central\nlsc = x_bar + (3 / np.sqrt(n)) * x_std  # Limite Superior de Controle\n\n# Configurar o estilo do gráfico\nsns.set_theme(style=\"ticks\") # Similar ao theme_classic()\n\n# Configurações de Figura\nfig, ax = plt.subplots(figsize=(5, 3), dpi=800)\n\nsns.lineplot(x=range(1, k+1), y=vec_means, marker=\"o\", color=\"black\", ax=ax)\n\n# Plotar as linhas de controle\nax.axhline(y=lsc, color=\"red\", linestyle=\"-\", label=f\"LSC = {lsc:.2f}\")\nax.axhline(y=lc, color=\"blue\", linestyle=\"-\", label=f\"$\\\\hat{{\\\\mu}}$ = {lc:.2f}\") # Usando LaTeX para mu\nax.axhline(y=lic, color=\"red\", linestyle=\"-\", label=f\"LIC = {lic:.2f}\")\n\n# Configurações de eixos e títulos\nax.set_ylim(18, 32)\n\n\n(18.0, 32.0)\n\n\nCódigo\nax.set_xlabel(\"Amostra\", weight=\"bold\", fontsize=12)\nax.set_ylabel(\"Medida\", weight=\"bold\", fontsize=12)\n\n# Configurações de Legenda\nax.legend(prop={\"size\":8, \"weight\": \"bold\"}, loc=\"upper right\", frameon=False) # bbox_to_anchor=(1, 0.5), \n\n# Outras configurações\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Exibição da Figura\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#demais-variações-do-gráfico-de-controle-de-barx",
    "href": "C2_PlotOfVariables.html#demais-variações-do-gráfico-de-controle-de-barx",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.4 Demais Variações do Gráfico de Controle de \\(\\bar{X}\\)",
    "text": "2.4 Demais Variações do Gráfico de Controle de \\(\\bar{X}\\)\n\n2.4.1 Gráficos de Médias e Amplitudes (\\(\\bar{X}\\) e \\(R\\))\nNa prática da construção de gráficos de controle, a média (\\(\\mu\\)) e o desvio-padrão (\\(\\sigma\\)) do processo raramente são conhecidos. Portanto, esses parâmetros precisam ser estimados a partir de dados amostrais. A premissa fundamental é que essas amostras, ou subgrupos, sejam coletadas em um momento em que o processo esteja operando sob controle estatístico.\nPara isso, Walter Shewhart sugeriu um método prático: a coleta de \\(m\\) subgrupos (geralmente entre 20 a 25) de tamanho \\(n\\) relativamente pequeno (4, 5 ou 6 itens cada). Essa abordagem visa a construção de “subgrupos racionais” com um baixo custo de amostragem.\nPara estimar a média global do processo, \\(\\mu\\), utilizamos a média das médias de todos os subgrupos. Sejam \\(\\bar{X}_1, \\bar{X}_2, \\ldots, \\bar{X}_m\\) as médias de cada um dos \\(m\\) subgrupos. O melhor estimador para \\(\\mu\\) é a grande média, denotada por \\(\\bar{\\bar{X}}\\): \\[\\bar{\\bar{X}} = \\frac{\\sum_{i=1}^{m} \\bar{X}_i}{m}.\\]\nOnde \\(\\bar{X}_i\\) é a média amostral do i-ésimo subgrupo. Por essa razão, o valor de \\(\\bar{\\bar{x}}\\) será usado como a linha central (LC) do gráfico \\(\\bar{X}\\).\nPara construir os limites de controle, tanto do gráfico \\(\\bar{X}\\) quanto do gráfico \\(R\\) (será visto mais a frente), precisamos de um estimador para o desvio-padrão do processo, \\(\\sigma\\). Essa estimativa pode ser obtida a partir dos desvios-padrões de cada subgrupo ou, mais comumente, a partir das amplitudes das amostras. Para esta análise, optaremos pelo método das amplitudes.\nA amplitude (\\(R\\)) de uma amostra é a diferença entre o valor máximo e o valor mínimo observados nela: \\[R = X_{\\text{max}} - X_{\\text{min}}.\\]\nSendo \\(R_1, R_2, \\ldots, R_m\\) as amplitudes de cada um dos \\(m\\) subgrupos, calculamos a amplitude média (\\(\\bar{R}\\)) como: \\[\\bar{R} = \\frac{\\sum_{i=1}^{m} R_i}{m}.\\]\nCom as estimativas da média (\\(\\bar{\\bar{x}}\\)) e da variabilidade (via \\(\\bar{R}\\)) do processo, podemos construir os limites de controle para o gráfico \\(\\bar{X}\\), que monitora a tendência central do processo.\n\\[\n\\text{Limites} = \\begin{cases} \\bar{\\bar{X}} + A_2 \\bar{R}, \\quad \\text{se o Limite for Inferior} \\\\ \\bar{\\bar{X}}, \\quad \\text{se o Limite for Central} \\\\ \\bar{\\bar{X}} - A_2 \\bar{R}, \\quad \\text{se o Limite for Superior} \\end{cases}.\n\\tag{2.2}\\]\nAs constantes \\(A_2\\) são tabeladas e dependem do tamanho do subgrupo (\\(n\\)). Elas podem ser encontradas em apêndices de livros de referência sobre o tema, como o “Introdução ao Controle de Qualidade” de Montgomery. Tal constantes e outras podem ser vistas na Figura 2.1.\n\n2.4.1.1 Exemplos Computacionais\nPara exemplificar o gráfico de controle recém apresentado, será usado o Exemplo 6.1. página 239 (Montgomery, 2009): Medições da Largura de Fluxo (mícrons) para o Processo de Cozimento Duro.\n\nR BaseR usando ggplot2Python\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Vetor de Médias\nvec.means &lt;- apply(samples.x, 1, mean)\n\n# Vetor de Amplitudes\nvec.range &lt;- apply(samples.x, 1, function(x) max(x) - min(x))\n\n# Estimar Algumas Quantidades\nx.bar &lt;- mean(vec.means)\nx.range &lt;- mean(vec.range)\n\n# Definir Constantes Estatíticas\nA2 &lt;- 0.729\n\n# Construir Limites\nLIC &lt;- x.bar - A2 * x.range # Limite Inferior de Controle\nLC  &lt;- x.bar                # Limite Central\nLSC &lt;- x.bar + A2 * x.range # Limite Inferior de Controle\n\n# Definir limites do eixo Y para garantir que tudo seja visível\nylim &lt;- c(min(vec.means, LIC) - 0.25, max(vec.means, LSC) + 0.25)\n\n# Criar o gráfico principal com pontos e linhas\nplot(x = 1:k, y = vec.means,\n     type = \"b\", # \"b\" para both (pontos e linhas)\n     xlab = \"Amostra\",\n     ylab = \"Medida\",\n     ylim = ylim,\n     pch = 19, # Tipo de ponto (círculo sólido)\n     col = \"black\",\n     font.lab = 2 # Deixa os títulos dos eixos em negrito\n)\n\n# Adicionar as linhas de controle\nabline(h = LIC, col = \"red\", lwd = 2)\nabline(h = LC, col = \"blue\", lwd = 2)\nabline(h = LSC, col = \"red\", lwd = 2)\n\n# Adicionar a legenda\nlegend(\"topright\",\n       legend = c(\n         bquote(LSC == .(round(LSC, 2))),\n         bquote(hat(mu) == .(round(LC, 2))),\n         bquote(LIC == .(round(LIC, 2)))\n       ),\n       col = c(\"red\", \"blue\", \"red\"),\n       lwd = 2,\n       cex = 0.75,\n       bty = \"solid\" # \"n\" Remove a caixa ao redor da legenda\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Vetor de Médias\nvec.means &lt;- apply(samples.x, 1, mean)\n\n# Vetor de Amplitudes\nvec.range &lt;- apply(samples.x, 1, function(x) max(x) - min(x))\n\n# Estimar Algumas Quantidades\nx.bar &lt;- mean(vec.means)\nx.range &lt;- mean(vec.range)\n\n# Definir Constantes Estatíticas\nA2 &lt;- 0.729\n\n# Construir Limites\nLIC &lt;- x.bar - A2 * x.range # Limite Inferior de Controle\nLC  &lt;- x.bar                # Limite Central\nLSC &lt;- x.bar + A2 * x.range # Limite Inferior de Controle\n\nlibrary(ggplot2)\n\n# Construir Gráfico de Controle no ggplot2\nggplot(data = NULL, aes(x = 1:nrow(samples.x), y = vec.means)) +\n  geom_point(size = 2) + geom_line() +\n  geom_hline(aes(yintercept = LIC, color = \"LIC\")) +\n  geom_hline(aes(yintercept = LC, color = \"LC\")) +\n  geom_hline(aes(yintercept = LSC, color = \"LSC\")) +\n  scale_color_manual(\n    values = c(\"LIC\" = \"red\", \"LC\" = \"blue\", \"LSC\" = \"red\"),\n    labels = c(\n      bquote(LIC == .(round(LIC, 2))),\n      bquote(mu[0] == .(round(x.bar, 2))),\n      bquote(LSC == .(round(LSC, 2)))\n    )\n  ) +\n  labs(\n    x = \"Amostra\",\n    y = \"Medida\",\n    color = \"Limites\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(\n    axis.title.x = element_text(face = \"bold\"),\n    axis.title.y = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ntbl61 = np.array([\n    [1, 1.3235, 1.4128, 1.6744, 1.4573],\n    [2, 1.4314, 1.3592, 1.6075, 1.4666],\n    [3, 1.4284, 1.4871, 1.4932, 1.4324],\n    [4, 1.5028, 1.6352, 1.3841, 1.2831],\n    [5, 1.5604, 1.2735, 1.5265, 1.4362],\n    [6, 1.5955, 1.5451, 1.3574, 1.3281],\n    [7, 1.6274, 1.5064, 1.8366, 1.4177],\n    [8, 1.4190, 1.4303, 1.6637, 1.6067],\n    [9, 1.3884, 1.7277, 1.5355, 1.5176],\n    [10, 1.4039, 1.6697, 1.5089, 1.6477],\n    [11, 1.4158, 1.7667, 1.4278, 1.5927],\n    [12, 1.5821, 1.3355, 1.5777, 1.3908],\n    [13, 1.2856, 1.4106, 1.4447, 1.6388],\n    [14, 1.4951, 1.4036, 1.5893, 1.6458],\n    [15, 1.3589, 1.2863, 1.5996, 1.2497],\n    [16, 1.5747, 1.5301, 1.5171, 1.1839],\n    [17, 1.3680, 1.7269, 1.3957, 1.5019],\n    [18, 1.4163, 1.3864, 1.3057, 1.6210],\n    [19, 1.5796, 1.4185, 1.6541, 1.5116],\n    [20, 1.7106, 1.4412, 1.2361, 1.3824],\n    [21, 1.4371, 1.5051, 1.3485, 1.5670],\n    [22, 1.4738, 1.5936, 1.6583, 1.4973],\n    [23, 1.5917, 1.4333, 1.5551, 1.5295],\n    [24, 1.6399, 1.5243, 1.5705, 1.5563],\n    [25, 1.5797, 1.3663, 1.6240, 1.3732]\n])\n\n# Obter apenas as amostras\nsamples_x = tbl61[:, 1:]\n\n# Vetor de médias (média de cada linha)\nvec_means = samples_x.mean(axis=1)\n\n# Vetor de desvios (desvio padrão amostral de cada linha, ddof=1)\nvec_range = samples_x.ptp(axis=1)\n\n# Estimar quantidades\nx_bar = vec_means.mean()\nx_range = vec_range.mean()\n\n# Definir Constantes Estatíticas\nA2 = 0.729\n\n# Construir limites\nlic = x_bar - A2 * x_range  # Limite Inferior de Controle\nlc  = x_bar                 # Limite Central\nlsc = x_bar + A2 * x_range  # Limite Inferior de Controle\n\n# Configurar o estilo do gráfico\nsns.set_theme(style=\"ticks\") # Similar ao theme_classic()\n\n# Configurações de Figura\nfig, ax = plt.subplots(figsize=(5, 3), dpi=800)\n\nsns.lineplot(x=range(1, samples_x.shape[0]+1), y=vec_means, marker=\"o\", color=\"black\", ax=ax)\n\n# Plotar as linhas de controle\nax.axhline(y=lsc, color=\"red\", linestyle=\"-\", label=f\"LSC = {lsc:.2f}\")\nax.axhline(y=lc, color=\"blue\", linestyle=\"-\", label=f\"$\\\\hat{{\\\\mu}}$ = {lc:.2f}\") # Usando LaTeX para mu\nax.axhline(y=lic, color=\"red\", linestyle=\"-\", label=f\"LIC = {lic:.2f}\")\n\n# Configurações de eixos e títulos\nax.set_ylim(min(vec_means.min(), lic) - 0.25, max(vec_means.max(), lsc) + 0.25)\n\n\n(1.0361290280000002, 1.9497169720000003)\n\n\nCódigo\nax.set_xlabel(\"Amostra\", weight=\"bold\", fontsize=12)\nax.set_ylabel(\"Medida\", weight=\"bold\", fontsize=12)\n\n# Configurações de Legenda\nax.legend(prop={\"size\":8, \"weight\": \"bold\"}, loc=\"upper right\", frameon=False) # bbox_to_anchor=(1, 0.5), \n\n# Outras configurações\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Exibição da Figura\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.2 Gráficos de Médias e Desvio Padrão (\\(\\bar{X}\\) e \\(S\\))\nOs gráficos \\(\\bar{X}\\) e \\(S\\) são a alternativa natural aos gráficos \\(\\bar{X}\\) e \\(R\\) quando o tamanho do subgrupo é moderado/maior (tipicamente \\(n&gt;10\\)) ou quando se prefere usar o desvio-padrão amostral como estimador da variabilidade. Para cada subgrupo \\(i\\) de tamanho \\(n\\) definimos:\n\nMédia amostral: \\(\\bar{X}_i = \\dfrac{1}{n}\\sum_{j=1}^{n} X_{ij}\\).\nDesvio padrão amostral (unbiased usual): \\(S_i = \\sqrt{\\dfrac{1}{n-1}\\sum_{j=1}^n (X_{ij} - \\bar{X}_i)^2}\\).\n\nSejam \\(\\bar{\\bar{X}} = \\dfrac{1}{m}\\sum_{i=1}^{m}\\bar{X}_i\\) e \\(\\bar{S} = \\dfrac{1}{m}\\sum_{i=1}^{m} S_i\\) as estimativas da média e da variabilidade do processo durante o período de referência (fase de set-up do gráfico). Os limites de controle são dados por:\n\\[\n\\text{Limites do gráfico }\\bar{X}:\\quad\n\\text{LSC} = \\bar{\\bar{X}} + A_3 \\,\\bar{S},\\qquad\n\\text{LC} = \\bar{\\bar{X}},\\qquad\n\\text{LIC} = \\bar{\\bar{X}} - A_3 \\,\\bar{S},\n\\]\nonde \\(A_3\\) é uma constante que depende do tamanho do subgrupo \\(n\\).\nInterpretação prática: examina-se primeiro o gráfico \\(S\\) (variabilidade). Se a variabilidade estiver sob controle (nenhum sinal no \\(S\\)), procede-se à análise do \\(\\bar{X}\\). Se o \\(S\\) indicar descontrole, não se interpreta o gráfico \\(\\bar{X}\\) até que a causa da variabilidade seja corrigida. Essa ordem evita conclusões equivocadas sobre a média quando a variabilidade do processo é instável.\n\n2.4.2.1 Exemplos Computacionais\nUsando os dados do exemplo anterior temos:\n\nR BaseR usando ggplot2Python\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Supondo matriz.data (m x n)\nvec.means &lt;- apply(samples.x, 1, mean)\nvec.sds   &lt;- apply(samples.x, 1, sd)\n\nxbar.bar &lt;- mean(vec.means)\ns.bar    &lt;- mean(vec.sds)\n\nA3 &lt;- 1.287 # EXEMPLO (depende de n)\n\nLC &lt;- xbar.bar\nLSC &lt;- xbar.bar + A3 * s.bar\nLIC &lt;- xbar.bar - A3 * s.bar\n\n# Definir limites do eixo Y para garantir que tudo seja visível\nylim &lt;- c(min(vec.means, LIC) - 0.25, max(vec.means, LSC) + 0.25)\n\n# Criar o gráfico principal com pontos e linhas\nplot(x = 1:k, y = vec.means,\n     type = \"b\", # \"b\" para both (pontos e linhas)\n     xlab = \"Amostra\",\n     ylab = \"Medida\",\n     ylim = ylim,\n     pch = 19, # Tipo de ponto (círculo sólido)\n     col = \"black\",\n     font.lab = 2 # Deixa os títulos dos eixos em negrito\n)\n\n# Adicionar as linhas de controle\nabline(h = LIC, col = \"red\", lwd = 2)\nabline(h = LC, col = \"blue\", lwd = 2)\nabline(h = LSC, col = \"red\", lwd = 2)\n\n# Adicionar a legenda\nlegend(\"topright\",\n       legend = c(\n         bquote(LSC == .(round(LSC, 2))),\n         bquote(hat(mu) == .(round(LC, 2))),\n         bquote(LIC == .(round(LIC, 2)))\n       ),\n       col = c(\"red\", \"blue\", \"red\"),\n       lwd = 2,\n       cex = 0.75,\n       bty = \"solid\" # \"n\" Remove a caixa ao redor da legenda\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Supondo matriz.data (m x n)\nvec.means &lt;- apply(samples.x, 1, mean)\nvec.sds   &lt;- apply(samples.x, 1, sd)\n\nxbar.bar &lt;- mean(vec.means)\ns.bar    &lt;- mean(vec.sds)\n\nA3 &lt;- 1.287 # EXEMPLO (depende de n)\n\nLC &lt;- xbar.bar\nLSC &lt;- xbar.bar + A3 * s.bar\nLIC &lt;- xbar.bar - A3 * s.bar\n\nlibrary(ggplot2)\n\n# Construir Gráfico de Controle no ggplot2\nggplot(data = NULL, aes(x = 1:nrow(samples.x), y = vec.means)) +\n  geom_point(size = 2) + geom_line() +\n  geom_hline(aes(yintercept = LIC, color = \"LIC\")) +\n  geom_hline(aes(yintercept = LC, color = \"LC\")) +\n  geom_hline(aes(yintercept = LSC, color = \"LSC\")) +\n  scale_color_manual(\n    values = c(\"LIC\" = \"red\", \"LC\" = \"blue\", \"LSC\" = \"red\"),\n    labels = c(\n      bquote(LIC == .(round(LIC, 2))),\n      bquote(mu[0] == .(round(x.bar, 2))),\n      bquote(LSC == .(round(LSC, 2)))\n    )\n  ) +\n  labs(\n    x = \"Amostra\",\n    y = \"Medida\",\n    color = \"Limites\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(\n    axis.title.x = element_text(face = \"bold\"),\n    axis.title.y = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ntbl61 = np.array([\n    [1, 1.3235, 1.4128, 1.6744, 1.4573],\n    [2, 1.4314, 1.3592, 1.6075, 1.4666],\n    [3, 1.4284, 1.4871, 1.4932, 1.4324],\n    [4, 1.5028, 1.6352, 1.3841, 1.2831],\n    [5, 1.5604, 1.2735, 1.5265, 1.4362],\n    [6, 1.5955, 1.5451, 1.3574, 1.3281],\n    [7, 1.6274, 1.5064, 1.8366, 1.4177],\n    [8, 1.4190, 1.4303, 1.6637, 1.6067],\n    [9, 1.3884, 1.7277, 1.5355, 1.5176],\n    [10, 1.4039, 1.6697, 1.5089, 1.6477],\n    [11, 1.4158, 1.7667, 1.4278, 1.5927],\n    [12, 1.5821, 1.3355, 1.5777, 1.3908],\n    [13, 1.2856, 1.4106, 1.4447, 1.6388],\n    [14, 1.4951, 1.4036, 1.5893, 1.6458],\n    [15, 1.3589, 1.2863, 1.5996, 1.2497],\n    [16, 1.5747, 1.5301, 1.5171, 1.1839],\n    [17, 1.3680, 1.7269, 1.3957, 1.5019],\n    [18, 1.4163, 1.3864, 1.3057, 1.6210],\n    [19, 1.5796, 1.4185, 1.6541, 1.5116],\n    [20, 1.7106, 1.4412, 1.2361, 1.3824],\n    [21, 1.4371, 1.5051, 1.3485, 1.5670],\n    [22, 1.4738, 1.5936, 1.6583, 1.4973],\n    [23, 1.5917, 1.4333, 1.5551, 1.5295],\n    [24, 1.6399, 1.5243, 1.5705, 1.5563],\n    [25, 1.5797, 1.3663, 1.6240, 1.3732]\n])\n\n# Obter apenas as amostras\nsamples_x = tbl61[:, 1:]\n\n# Vetor de médias (média de cada linha)\nvec_means = samples_x.mean(axis=1)\n\n# Vetor de desvios (desvio padrão amostral de cada linha, ddof=1)\nvec_std = samples_x.std(axis=1)\n\n# Estimar quantidades\nx_bar = vec_means.mean()\nx_std = vec_std.mean()\n\n# Definir Constantes Estatíticas\nA3 = 1.287 # EXEMPLO (depende de n)\n\n# Construir limites\nlic = x_bar - A3 * x_std  # Limite Inferior de Controle\nlc  = x_bar               # Limite Central\nlsc = x_bar + A3 * x_std  # Limite Inferior de Controle\n\n# Configurar o estilo do gráfico\nsns.set_theme(style=\"ticks\") # Similar ao theme_classic()\n\n# Configurações de Figura\nfig, ax = plt.subplots(figsize=(5, 3), dpi=800)\n\nsns.lineplot(x=range(1, samples_x.shape[0]+1), y=vec_means, marker=\"o\", color=\"black\", ax=ax)\n\n# Plotar as linhas de controle\nax.axhline(y=lsc, color=\"red\", linestyle=\"-\", label=f\"LSC = {lsc:.2f}\")\nax.axhline(y=lc, color=\"blue\", linestyle=\"-\", label=f\"$\\\\hat{{\\\\mu}}$ = {lc:.2f}\") # Usando LaTeX para mu\nax.axhline(y=lic, color=\"red\", linestyle=\"-\", label=f\"LIC = {lic:.2f}\")\n\n# Configurações de eixos e títulos\nax.set_ylim(min(vec_means.min(), lic) - 0.25, max(vec_means.max(), lsc) + 0.25)\n\n\n(1.1010968974167958, 1.8847491025832046)\n\n\nCódigo\nax.set_xlabel(\"Amostra\", weight=\"bold\", fontsize=12)\nax.set_ylabel(\"Medida\", weight=\"bold\", fontsize=12)\n\n# Configurações de Legenda\nax.legend(prop={\"size\":8, \"weight\": \"bold\"}, loc=\"upper right\", frameon=False) # bbox_to_anchor=(1, 0.5), \n\n# Outras configurações\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Exibição da Figura\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#gráfico-de-controle-para-r",
    "href": "C2_PlotOfVariables.html#gráfico-de-controle-para-r",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.5 Gráfico de Controle para \\(R\\)",
    "text": "2.5 Gráfico de Controle para \\(R\\)\nO gráfico \\(R\\) monitora a amplitude de cada subgrupo: \\(R_i = \\max_j X_{ij} - \\min_j X_{ij}\\). Seja \\(\\bar{R} = \\dfrac{1}{m}\\sum_{i=1}^{m} R_i\\) a amplitude média. Os limites de controle do gráfico \\(R\\) são:\n\\[\n\\text{LC}_R = \\bar{R},\\qquad\n\\text{LSC}_R = D_4\\,\\bar{R},\\qquad\n\\text{LIC}_R = D_3\\,\\bar{R},\n\\]\nonde \\(D_3\\) e \\(D_4\\) são constantes tabeladas (dependem de \\(n\\)). Para muitos tamanhos de subgrupo pequenos, \\(D_3 = 0\\) (o que implica ausência de limite inferior prático). As constantes \\(A_2, D_3, D_4\\) são usadas em conjunto com o gráfico \\(\\bar{X}\\) quando a estimativa da variabilidade se faz via amplitudes (ex.: \\(\\bar{\\bar{X}} \\pm A_2 \\bar{R}\\)).\nUso prático e ordem de verificação: sempre verifique se o gráfico \\(R\\) está sob controle antes de interpretar o gráfico \\(\\bar{X}\\). Se o R indicar descontrole, a causa deve ser investigada (variação no processo, mudança de máquina, operador, matéria-prima, instrumento de inspeção etc.) e corrigida.\n\n2.5.1 Exemplos Computacionais\nFazendo uso dos dados dos exemplos anteriores, temos:\n\nR BaseR usando ggplot2Python\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Supondo matriz.data (m x n)\nvec.range &lt;- apply(samples.x, 1, function(x) max(x) - min(x))\n\nR.bar &lt;- mean(vec.range)\n\n# Definir Constantes Estatíticas\nD3 &lt;- 0.00  # exemplo (depende de n)\nD4 &lt;- 2.282 # exemplo (depende de n)\n\nLC &lt;- R.bar\nLSC &lt;- D4 * R.bar\nLIC &lt;- D3 * R.bar\n\n# Definir limites do eixo Y para garantir que tudo seja visível\nylim &lt;- c(min(vec.range, LIC) - 0.25, max(vec.range, LSC) + 0.25)\n\n# Criar o gráfico principal com pontos e linhas\nplot(x = 1:k, y = vec.range,\n     type = \"b\", # \"b\" para both (pontos e linhas)\n     xlab = \"Amostra\",\n     ylab = \"Medida\",\n     ylim = ylim,\n     pch = 19, # Tipo de ponto (círculo sólido)\n     col = \"black\",\n     font.lab = 2 # Deixa os títulos dos eixos em negrito\n)\n\n# Adicionar as linhas de controle\nabline(h = LIC, col = \"red\", lwd = 2)\nabline(h = LC, col = \"blue\", lwd = 2)\nabline(h = LSC, col = \"red\", lwd = 2)\n\n# Adicionar a legenda\nlegend(\"topright\",\n       legend = c(\n         bquote(LSC == .(round(LSC, 2))),\n         bquote(LC == .(round(LC, 2))),\n         bquote(LIC == .(round(LIC, 2)))\n       ),\n       col = c(\"red\", \"blue\", \"red\"),\n       lwd = 2,\n       cex = 0.75,\n       bty = \"solid\" # \"n\" Remove a caixa ao redor da legenda\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Supondo matriz.data (m x n)\nvec.range &lt;- apply(samples.x, 1, function(x) max(x) - min(x))\n\nR.bar &lt;- mean(vec.range)\n\n# Definir Constantes Estatíticas\nD3 &lt;- 0.00  # exemplo (depende de n)\nD4 &lt;- 2.282 # exemplo (depende de n)\n\nLC &lt;- R.bar\nLSC &lt;- D4 * R.bar\nLIC &lt;- D3 * R.bar\n\nlibrary(ggplot2)\n\n# Construir Gráfico de Controle no ggplot2\nggplot(data = NULL, aes(x = 1:nrow(samples.x), y = vec.range)) +\n  geom_point(size = 2) + geom_line() +\n  geom_hline(aes(yintercept = LIC, color = \"LIC\")) +\n  geom_hline(aes(yintercept = LC, color = \"LC\")) +\n  geom_hline(aes(yintercept = LSC, color = \"LSC\")) +\n  scale_color_manual(\n    values = c(\"LIC\" = \"red\", \"LC\" = \"blue\", \"LSC\" = \"red\"),\n    labels = c(\n      bquote(LIC == .(round(LIC, 2))),\n      bquote(LC == .(round(R.bar, 2))),\n      bquote(LSC == .(round(LSC, 2)))\n    )\n  ) +\n  labs(\n    x = \"Amostra\",\n    y = \"Medida\",\n    color = \"Limites\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(\n    axis.title.x = element_text(face = \"bold\"),\n    axis.title.y = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ntbl61 = np.array([\n    [1, 1.3235, 1.4128, 1.6744, 1.4573],\n    [2, 1.4314, 1.3592, 1.6075, 1.4666],\n    [3, 1.4284, 1.4871, 1.4932, 1.4324],\n    [4, 1.5028, 1.6352, 1.3841, 1.2831],\n    [5, 1.5604, 1.2735, 1.5265, 1.4362],\n    [6, 1.5955, 1.5451, 1.3574, 1.3281],\n    [7, 1.6274, 1.5064, 1.8366, 1.4177],\n    [8, 1.4190, 1.4303, 1.6637, 1.6067],\n    [9, 1.3884, 1.7277, 1.5355, 1.5176],\n    [10, 1.4039, 1.6697, 1.5089, 1.6477],\n    [11, 1.4158, 1.7667, 1.4278, 1.5927],\n    [12, 1.5821, 1.3355, 1.5777, 1.3908],\n    [13, 1.2856, 1.4106, 1.4447, 1.6388],\n    [14, 1.4951, 1.4036, 1.5893, 1.6458],\n    [15, 1.3589, 1.2863, 1.5996, 1.2497],\n    [16, 1.5747, 1.5301, 1.5171, 1.1839],\n    [17, 1.3680, 1.7269, 1.3957, 1.5019],\n    [18, 1.4163, 1.3864, 1.3057, 1.6210],\n    [19, 1.5796, 1.4185, 1.6541, 1.5116],\n    [20, 1.7106, 1.4412, 1.2361, 1.3824],\n    [21, 1.4371, 1.5051, 1.3485, 1.5670],\n    [22, 1.4738, 1.5936, 1.6583, 1.4973],\n    [23, 1.5917, 1.4333, 1.5551, 1.5295],\n    [24, 1.6399, 1.5243, 1.5705, 1.5563],\n    [25, 1.5797, 1.3663, 1.6240, 1.3732]\n])\n\n# Obter apenas as amostras\nsamples_x = tbl61[:, 1:]\n\n# Vetor de desvios (desvio padrão amostral de cada linha, ddof=1)\nvec_range = samples_x.ptp(axis=1)\n\n# Estimar quantidades\nx_range = vec_range.mean()\n\n# Definir Constantes Estatíticas\nD3 = 0.00  # exemplo (depende de n)\nD4 = 2.282 # exemplo (depende de n)\n\n# Construir limites\nlic = D3 * x_range  # Limite Inferior de Controle\nlc  = x_range       # Limite Central\nlsc = D4 * x_range  # Limite Inferior de Controle\n\n# Configurar o estilo do gráfico\nsns.set_theme(style=\"ticks\") # Similar ao theme_classic()\n\n# Configurações de Figura\nfig, ax = plt.subplots(figsize=(5, 3), dpi=800)\n\nsns.lineplot(x=range(1, samples_x.shape[0]+1), y=vec_range, marker=\"o\", color=\"black\", ax=ax)\n\n# Plotar as linhas de controle\nax.axhline(y=lsc, color=\"red\", linestyle=\"-\", label=f\"LSC = {lsc:.2f}\")\nax.axhline(y=lc, color=\"blue\", linestyle=\"-\", label=f\"$\\\\hat{{\\\\mu}}$ = {lc:.2f}\") # Usando LaTeX para mu\nax.axhline(y=lic, color=\"red\", linestyle=\"-\", label=f\"LIC = {lic:.2f}\")\n\n# Configurações de eixos e títulos\nax.set_ylim(min(vec_range.min(), lic) - 0.25, max(vec_range.max(), lsc) + 0.25)\n\n\n(-0.25, 0.897330376)\n\n\nCódigo\nax.set_xlabel(\"Amostra\", weight=\"bold\", fontsize=12)\nax.set_ylabel(\"Medida\", weight=\"bold\", fontsize=12)\n\n# Configurações de Legenda\nax.legend(prop={\"size\":8, \"weight\": \"bold\"}, loc=\"upper right\", frameon=False) # bbox_to_anchor=(1, 0.5), \n\n# Outras configurações\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Exibição da Figura\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#gráfico-de-controle-para-s",
    "href": "C2_PlotOfVariables.html#gráfico-de-controle-para-s",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.6 Gráfico de Controle para \\(S\\)",
    "text": "2.6 Gráfico de Controle para \\(S\\)\nO gráfico \\(S\\) monitora o desvio-padrão amostral \\(S_i\\) de cada subgrupo. Como já mostrado em 2.4.2, os limites do gráfico \\(S\\) são:\n\\[\n\\text{LSC}_S = B_4\\,\\bar{S},\\qquad\n\\text{LC}_S = \\bar{S},\\qquad\n\\text{LIC}_S = B_3\\,\\bar{S},\n\\]\ncom \\(B_3,B_4\\) tabelados. O gráfico \\(S\\) é geralmente preferido ao gráfico \\(R\\) quando \\(n\\) é maior (maior precisão no estimador do desvio-padrão) e quando subgrupos possuem tamanhos variados. Além disso, o cálculo de constantes para \\(S\\) (A\\(_3\\), B\\(_3\\), B\\(_4\\)) pode ser feito por fórmulas que envolvem a constante \\(c_4\\) (fator de correção de viés do estimador do desvio-padrão) quando necessário. ([East London NHS Foundation Trust][3])\nVantagens do S-chart sobre R-chart:\n\nmelhor desempenho (menor viés) para amostras maiores;\npermite tratamento mais natural quando o tamanho do subgrupo varia;\ngeralmente leva a limites mais estáveis para variâncias estimadas.\n\n\n2.6.1 Exemplos Computacionais\nFazendo uso dos dados dos exemplos anteriores, temos:\n\nR BaseR usando ggplot2Python\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Supondo matriz.data (m x n)\nvec.std &lt;- apply(samples.x, 1, sd)\n\nS.bar &lt;- mean(vec.std)\n\n# Definir Constantes Estatíticas\nB3 &lt;- 0.030 # exemplo (depende de n)\nB4 &lt;- 1.970 # exemplo (depende de n)\n\nLC &lt;- S.bar\nLSC &lt;- B4 * S.bar\nLIC &lt;- B3 * S.bar\n\n# Definir limites do eixo Y para garantir que tudo seja visível\nylim &lt;- c(min(vec.std, LIC) - 0.25, max(vec.std, LSC) + 0.25)\n\n# Criar o gráfico principal com pontos e linhas\nplot(x = 1:k, y = vec.std,\n     type = \"b\", # \"b\" para both (pontos e linhas)\n     xlab = \"Amostra\",\n     ylab = \"Medida\",\n     ylim = ylim,\n     pch = 19, # Tipo de ponto (círculo sólido)\n     col = \"black\",\n     font.lab = 2 # Deixa os títulos dos eixos em negrito\n)\n\n# Adicionar as linhas de controle\nabline(h = LIC, col = \"red\", lwd = 2)\nabline(h = LC, col = \"blue\", lwd = 2)\nabline(h = LSC, col = \"red\", lwd = 2)\n\n# Adicionar a legenda\nlegend(\"topright\",\n       legend = c(\n         bquote(LSC == .(round(LSC, 2))),\n         bquote(LC == .(round(LC, 2))),\n         bquote(LIC == .(round(LIC, 2)))\n       ),\n       col = c(\"red\", \"blue\", \"red\"),\n       lwd = 2,\n       cex = 0.75,\n       bty = \"solid\" # \"n\" Remove a caixa ao redor da legenda\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Supondo matriz.data (m x n)\nvec.std &lt;- apply(samples.x, 1, sd)\n\nS.bar &lt;- mean(vec.std)\n\n# Definir Constantes Estatíticas\nB3 &lt;- 0.030 # exemplo (depende de n)\nB4 &lt;- 1.970 # exemplo (depende de n)\n\nLC &lt;- S.bar\nLSC &lt;- B4 * S.bar\nLIC &lt;- B3 * S.bar\n\nlibrary(ggplot2)\n\n# Construir Gráfico de Controle no ggplot2\nggplot(data = NULL, aes(x = 1:nrow(samples.x), y = vec.std)) +\n  geom_point(size = 2) + geom_line() +\n  geom_hline(aes(yintercept = LIC, color = \"LIC\")) +\n  geom_hline(aes(yintercept = LC, color = \"LC\")) +\n  geom_hline(aes(yintercept = LSC, color = \"LSC\")) +\n  scale_color_manual(\n    values = c(\"LIC\" = \"red\", \"LC\" = \"blue\", \"LSC\" = \"red\"),\n    labels = c(\n      bquote(LIC == .(round(LIC, 2))),\n      bquote(LC == .(round(S.bar, 2))),\n      bquote(LSC == .(round(LSC, 2)))\n    )\n  ) +\n  labs(\n    x = \"Amostra\",\n    y = \"Medida\",\n    color = \"Limites\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(\n    axis.title.x = element_text(face = \"bold\"),\n    axis.title.y = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ntbl61 = np.array([\n    [1, 1.3235, 1.4128, 1.6744, 1.4573],\n    [2, 1.4314, 1.3592, 1.6075, 1.4666],\n    [3, 1.4284, 1.4871, 1.4932, 1.4324],\n    [4, 1.5028, 1.6352, 1.3841, 1.2831],\n    [5, 1.5604, 1.2735, 1.5265, 1.4362],\n    [6, 1.5955, 1.5451, 1.3574, 1.3281],\n    [7, 1.6274, 1.5064, 1.8366, 1.4177],\n    [8, 1.4190, 1.4303, 1.6637, 1.6067],\n    [9, 1.3884, 1.7277, 1.5355, 1.5176],\n    [10, 1.4039, 1.6697, 1.5089, 1.6477],\n    [11, 1.4158, 1.7667, 1.4278, 1.5927],\n    [12, 1.5821, 1.3355, 1.5777, 1.3908],\n    [13, 1.2856, 1.4106, 1.4447, 1.6388],\n    [14, 1.4951, 1.4036, 1.5893, 1.6458],\n    [15, 1.3589, 1.2863, 1.5996, 1.2497],\n    [16, 1.5747, 1.5301, 1.5171, 1.1839],\n    [17, 1.3680, 1.7269, 1.3957, 1.5019],\n    [18, 1.4163, 1.3864, 1.3057, 1.6210],\n    [19, 1.5796, 1.4185, 1.6541, 1.5116],\n    [20, 1.7106, 1.4412, 1.2361, 1.3824],\n    [21, 1.4371, 1.5051, 1.3485, 1.5670],\n    [22, 1.4738, 1.5936, 1.6583, 1.4973],\n    [23, 1.5917, 1.4333, 1.5551, 1.5295],\n    [24, 1.6399, 1.5243, 1.5705, 1.5563],\n    [25, 1.5797, 1.3663, 1.6240, 1.3732]\n])\n\n# Obter apenas as amostras\nsamples_x = tbl61[:, 1:]\n\n# Vetor de desvios (desvio padrão amostral de cada linha, ddof=1)\nvec_std = samples_x.std(axis=1)\n\n# Estimar quantidades\nS_bar = vec_std.mean()\n\n# Definir Constantes Estatíticas\nB3 = 0.030 # exemplo (depende de n)\nB4 = 1.970 # exemplo (depende de n)\n\n# Construir limites\nlic = B3 * S_bar  # Limite Inferior de Controle\nlc  = S_bar       # Limite Central\nlsc = B4 * S_bar  # Limite Inferior de Controle\n\n# Configurar o estilo do gráfico\nsns.set_theme(style=\"ticks\") # Similar ao theme_classic()\n\n# Configurações de Figura\nfig, ax = plt.subplots(figsize=(5, 3), dpi=800)\n\nsns.lineplot(x=range(1, samples_x.shape[0]+1), y=vec_std, marker=\"o\", color=\"black\", ax=ax)\n\n# Plotar as linhas de controle\nax.axhline(y=lsc, color=\"red\", linestyle=\"-\", label=f\"LSC = {lsc:.2f}\")\nax.axhline(y=lc, color=\"blue\", linestyle=\"-\", label=f\"LC = {lc:.2f}\") # Usando LaTeX para mu\nax.axhline(y=lic, color=\"red\", linestyle=\"-\", label=f\"LIC = {lic:.2f}\")\n\n# Configurações de eixos e títulos\nax.set_ylim(min(vec_std.min(), lic) - 0.25, max(vec_std.max(), lsc) + 0.25)\n\n\n(-0.24669403024281575, 0.46709201405509926)\n\n\nCódigo\nax.set_xlabel(\"Amostra\", weight=\"bold\", fontsize=12)\nax.set_ylabel(\"Medida\", weight=\"bold\", fontsize=12)\n\n# Configurações de Legenda\nax.legend(prop={\"size\":8, \"weight\": \"bold\"}, loc=\"upper right\", frameon=False) # bbox_to_anchor=(1, 0.5), \n\n# Outras configurações\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Exibição da Figura\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#considerações-finais",
    "href": "C2_PlotOfVariables.html#considerações-finais",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.7 Considerações Finais",
    "text": "2.7 Considerações Finais\nAs referências usadas foram Montgomery (2012), Technology (n.d.), (ELFT) (n.d.), Excel (n.d.) e UFJF (n.d.).\n\n\n\n\n\n\n\n\n\n\n\n(ELFT), East London Foundation Trust. n.d. «Shewhart X-Bar and S Chart Formulas and Constants». PDF. https://www.elft.nhs.uk/sites/default/files/import-news/x-bar-s-Chart-Formula.pdf.\n\n\nExcel, SPC for. n.d. «X-bar-S Control Charts: Part 1». Webpage. https://www.spcforexcel.com/knowledge/variable-control-charts/xbar-s-control-charts-part-1/.\n\n\nMontgomery, Douglas C. 2012. Statistical Quality Control. 7.ª ed. John Wiley & Sons.\n\n\nTechnology, Massachusetts Institute of. n.d. «Tables of Constants for Control Charts». Lecture Notes / PDF. https://web.mit.edu/2.810/www/files/readings/ControlChartConstantsAndFormulae.pdf.\n\n\nUFJF, Bessegato /. n.d. «Table of Control Chart Constants». PDF. https://www.bessegato.com.br/UFJF/resources/table_of_control_chart_constants_old.pdf.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html",
    "href": "C3_CCO_CMS.html",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "",
    "text": "3.1 Introdução\nEspecificar o plano amostral, a frequência de coleta e os limites de controle de um processo são algumas das decisões críticas na construção de gráficos de controle. Na inviabilidade de inspecionar todos os itens produzidos, são selecionados uma certa quantidade por lote de forma aleatória para composição das amostras. Naturalmente, quanto mais itens amostrados, maior a aproximação da representação real do processo e consequente maior controle. Logo, as alternativas viáveis são, ou tomar amostras pequenas com maior frequência, ou amostras grandes com menor frequência (Carpinetti 2003; Montgomery 2012).\nA depender do número defeitos presentes, o lote pode ser aceito ou rejeitado, parelho ao teste de hipóteses:\n\\[\n\\left\\{ \\begin{array} HH_0: p = p_0\\\\ H_1: p \\neq p_0 \\end{array} \\right.\n\\]\nonde \\(p\\) representa a proporção de defeitos na produção (Botter 2013).\nQuando estabelecemos limites de controle afastados da linha central, aumentamos a tolerância do processo, diminuindo assim o risco de ocorrer pontos fora dos limites. Esse risco é denominado erro tipo I (\\(\\alpha\\)) ou risco do produtor, responsável por indicar condições fora do controle sem causa atribuível (alarme falso).\nA presença de baixos valores para o erro tipo I dificulta a detecção de defeitos reais, implicando no aumento de itens dentro dos limites de controle, quando o processo na realidade estiver fora de controle. A esse risco denominamos erro do tipo II (\\(\\beta\\)) ou risco do consumidor.\nNo caso de aproximação dos limites de controle da linha central gera o efeito contrário; quando o risco do produtor aumenta, o do consumidor diminui (Montgomery 2012; Botter 2013). O cenário desejável é a identificação eficiente desses defeitos antes que ele seja repassado ao consumidor, garantindo a qualidade do produto.\nPara um processo controlado sob condição de normalidade – \\(X_{i} \\sim N(\\mu, \\sigma^2)\\) – em um nível de operação (\\(L\\)) temos que a probabilidade do processo estar sob controle é dada por\n\\[\nP\\left[LIC \\leq \\bar{X}_i \\leq LSC \\right] \\Rightarrow P\\left[\\dfrac{\\mu -L\\sigma}{\\sqrt{n}} \\leq \\bar{X}_i \\leq \\dfrac{\\mu + L\\sigma}{\\sqrt{n}}\\right],\n\\] onde \\(LIC\\) representa o limite inferior de controle e \\(LSC\\), o limite superior de controle, \\(\\sigma\\) o desvio-padrão da operação e \\(n\\), o número de amostras.\nPara um processo operado em \\(3\\sigma\\) (\\(L=3\\)), temos que \\[\\therefore P\\left[ \\dfrac{\\mu -3\\sigma}{\\sqrt{n}} \\leq \\bar{X}_i \\leq \\dfrac{\\mu + 3\\sigma}{\\sqrt{n}}\\right] = 0.9973.\\]\nPela normalização dos dados – \\(X_{i} \\sim N(0, 1)\\)–, o erro tipo II corresponde a 99,73% e o erro tipo I a 0,27%. Em outras palavras, o processo acusará 27 alarmes falsos em 10.000 itens produzidos.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html#curva-característica-da-operação-cco",
    "href": "C3_CCO_CMS.html#curva-característica-da-operação-cco",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "3.2 Curva Característica da Operação (CCO)",
    "text": "3.2 Curva Característica da Operação (CCO)\nA capacidade dos gráficos \\(\\bar{X}\\) e \\(R\\) de detectar mudanças no processo é descrita pelas chamadas Curvas Características de Operação (CCO), utilizadas na fase II de monitoramento de um processo. Considerando que a variabilidade do processo se mantém constante ao longo do tempo, \\(\\beta\\), nesse caso, representa a probabilidade de não serem detectadas mudanças na média na amostra subsequente (Montgomery 2012).\nEm termos probabilísticos, o risco do consumidor (\\(\\beta\\)) para uma dada média em um nível \\(\\mu_0\\) mudar para \\(\\mu_1\\), sendo \\(\\mu_1 = \\mu_0 + k\\sigma\\), pode descrito ser como\n\\[\n\\beta = P \\left[ LIC \\leq \\bar{X} \\leq LSC | \\mu = \\mu_1 = \\mu_0 + k\\sigma \\right],\n\\]\nonde \\(k\\) representa o número de desvios (\\(\\sigma\\)) em relação à média (\\(\\mu_0\\)).\nLevando em conta a média amostral com distribuição normal \\(\\bar{x} \\sim N(\\mu, \\sigma^2/n)\\) e limites superior e inferior de controle \\(LSE = \\mu_0 + L\\sigma/\\sqrt{n}\\) e \\(LIE = \\mu_0 - L\\sigma/\\sqrt{n}\\), os termos podem ser trabalhados em termos de função de distribuição cumulativa normal \\(\\Phi(\\cdot)\\). Desta forma, a função \\(\\beta\\) pode ser expressa como\n\\[ \\beta = \\Phi \\left[\\dfrac{LSE - \\mu_1}{\\sigma \\sqrt{n}}\\right] - \\Phi \\left[\\dfrac{LIE + \\mu_1}{\\sigma \\sqrt{n}}\\right].\n\\]\nA partir das definições, podemos realizar as substituições dos limites de controle amostrais e da nova média \\(\\mu_1\\), resultando em\n\\[\n\\beta = \\Phi \\left[\\dfrac{(\\mu_0 + L\\sigma/\\sqrt{n}) - (\\mu_0 + k\\sigma)}{\\sigma \\sqrt{n}}\\right] - \\Phi \\left[\\dfrac{(\\mu_0 - L\\sigma/\\sqrt{n}) + (\\mu_0 + k\\sigma)}{\\sigma \\sqrt{n}}\\right].\n\\]\nFazendo os devidos ajustes de cálculo, a equação acima pode ser simplificada para\n\\[\n\\beta = \\Phi \\left[L - k\\sqrt{n}\\right] - \\Phi \\left[-L - k\\sqrt{n}\\right].\n\\]\nPara ilustrar sua aplicação, tomemos um processo que opera em \\(3\\sigma\\), coletando cinco amostras por inspeção (\\(n=5\\)). Para determinar a probabilidade de deteção de mudança na média em dois desvios-padrão (\\(k=2\\)) na primeira amostra após o deslocamento para \\(\\mu_1 = \\mu_0 + 2\\sigma\\), incialmente calculamos a probaibilidade de não-detecção (\\(\\beta\\)):\n\nRPython\n\n\n\nCódigo\nL = 3 ; k = 2\nbeta = pnorm(L - k*sqrt(5)) - pnorm(-L - k*sqrt(5))\nround(beta, 4)\n\n[1] 0.0705\n\n\n\n\nCódigo\nimport numpy as np\nfrom scipy.stats import norm\nL = 3 ; k = 2\nbeta = norm.cdf(L - k*np.sqrt(5)) - norm.cdf(-L - k*np.sqrt(5))\nprint(round(beta, 4))\n\n\n0.0705\n\n\n\n\n\nLogo, a probabilidade de decteção do deslocamento é \\(1-\\beta = 1 - 0,0705 = 0,9295\\) ou 92,95%. De forma progressiva, podemos construir as CCOs para gráfico de médias (\\(\\bar{X}\\)) para diferentes números de amostra. A definição dos pontos da curva depende do cruzamento entre o valor do risco \\(\\beta\\) em relação a extensão do deslocamento (\\(k\\)) para um número de amostras (\\(n\\)).\n\nRPython\n\n\n\nCódigo\nL = 3                             # Nível do processo \nk = seq(0, 5, length.out = 100)   # Valores para deslocamento\n\n# Probabilidade de detecção de mudanças (erro tipo II)\nbeta_1 = pnorm(L - k*sqrt(1)) - pnorm(-L - k*sqrt(1))     # para n = 1\nbeta_2 = pnorm(L - k*sqrt(2)) - pnorm(-L - k*sqrt(2))     # para n = 2\nbeta_5 = pnorm(L - k*sqrt(5)) - pnorm(-L - k*sqrt(5))     # para n = 5\nbeta_10 = pnorm(L - k*sqrt(10)) - pnorm(-L - k*sqrt(10))  # para n = 10\nbeta_20 = pnorm(L - k*sqrt(20)) - pnorm(-L - k*sqrt(20))  # para n = 20\n\n# Gráfico comparativo das Curvas\n#par(mfrow = c(1, 1))\nplot(k, beta_1, type = \"l\", lwd = 1.25, lty=2, \n     col = \"black\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, beta_2, type = \"l\", lwd = 1.25, lty=2, \n     col = \"red\", axes=F, xlab=\"\",ylab=\"\")\npoints(1,pnorm(L - 1*sqrt(2)) - pnorm(-L - 1*sqrt(2)), col = \"red\", pch = 19, cex = 1.25) \npar (new = TRUE)\nplot(k, beta_5, type = \"l\", lwd = 1.25, lty=2, \n     col = \"green\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, beta_10, type = \"l\", lwd = 1.25, lty=2, \n     col = \"blue\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, beta_20, type = \"l\", lwd = 1.25, lty=2, \n     col = \"purple\", axes=T,\n     xlab = \"Deslocamento da Média (k)\",\n     ylab = \"Risco do Consumidor (β)\",\n     main = \"Curva Característica de Operação -- Gráfico X-bar\",\n     ylim = c(0,1))\npoints(1,pnorm(L - 1*sqrt(20)) - pnorm(-L - 1*sqrt(20)), col = \"red\", pch = 19, cex = 1.25) \ngrid()\nlegend(\"topright\", title=\"Amostras\", lwd = 1.25, lty = 2,\n     legend = c(\"n = 1\", \"n = 2\", \"n = 5\", \"n = 10\", \"n = 20\"),  \n     col = c(\"black\", \"red\", \"green\", \"blue\", \"purple\"))\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\nL = 3                       # Nível do processo \nk = np.linspace(0, 5, 100)  # Valores para deslocamento\n\n# Probabilidade de detecção de mudanças (erro tipo II)\nbeta_1 = norm.cdf(L - k*np.sqrt(1)) - norm.cdf(-L - k*np.sqrt(1))    # para n = 1\nbeta_2 = norm.cdf(L - k*np.sqrt(2)) - norm.cdf(-L - k*np.sqrt(2))    # para n = 2\nbeta_5 = norm.cdf(L - k*np.sqrt(5)) - norm.cdf(-L - k*np.sqrt(5))    # para n = 5\nbeta_10 = norm.cdf(L - k*np.sqrt(10)) - norm.cdf(-L - k*np.sqrt(10)) # para n = 10\nbeta_20 = norm.cdf(L - k*np.sqrt(20)) - norm.cdf(-L - k*np.sqrt(20)) # para n = 20\n\n# Gráfico comparativo das Curvas\nplt.plot(k, beta_1, linestyle = '--', linewidth = .75, color = \"black\", label = 'n = 1')\nplt.plot(k, beta_2, linestyle = '--', linewidth = .75, color = \"red\", label = 'n = 2')\nplt.plot(1, norm.cdf(L - 1*np.sqrt(2)) - norm.cdf(-L - 1*np.sqrt(2)), 'ro')\nplt.plot(k, beta_5, linestyle = '--', linewidth = .75, color = \"green\", label = 'n = 5')\nplt.plot(k, beta_10, linestyle = '--', linewidth = .75, color = \"blue\", label = 'n = 10')\nplt.plot(k, beta_20, linestyle = '--', linewidth = .75, color = \"purple\", label = 'n = 20')\nplt.plot(1, norm.cdf(L - 1*np.sqrt(20)) - norm.cdf(-L - 1*np.sqrt(20)), 'ro')\nplt.xlabel('Deslocamento da Média (k)')\nplt.ylabel('Risco do Consumidor (β)')\nplt.title('Curva Característica de Operação -- Gráfico X-bar')\nplt.ylim(0,1)\n\n\n(0.0, 1.0)\n\n\nCódigo\nplt.legend(title='Amostras', fontsize=9)\nplt.grid(True, alpha=.3)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nÉ notável que um número pequeno de amostras implica em um baixo poder de detecção. Por exemplo, em um caso de inspeção com duas amostras (\\(n=2\\), destacado no gráfico no ponto vermelho mais acima), a probabilidade de identificação de uma mudança em um desvio-padrão (\\(k=1\\)) na amostra subsequente é de apenas 5,64% (\\(\\beta=0.9436 \\therefore 1-\\beta=0.0564\\)). Já com \\(n=20\\) (ponto vermelho mais abaixo), a detecção efetiva nas mesmas condições é de 92,95% na primeira amostra após a mudança na média (\\(\\beta=0.0705 \\therefore 1-\\beta=0.9295\\)). Isso demonstra o comportamento natural de melhoria na detecção de defeitos conforme o número de amostras é ampliado.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html#compimento-médio-da-sequência-cms",
    "href": "C3_CCO_CMS.html#compimento-médio-da-sequência-cms",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "3.3 Compimento Médio da Sequência (CMS)",
    "text": "3.3 Compimento Médio da Sequência (CMS)\nOutra análise possível é a definição da probabilidade de identificar o deslocamento a cada nova amostra. Utilizando o exemplo já mencionado (\\(L=3\\), \\(n=2\\), \\(k=1\\) e \\(\\beta = 0.9436\\)), a detecção de mudanças na segunda amostra é dado por \\(\\beta(1-\\beta)\\), isto é, a oscilação não foi apontada na primeira amostra (risco \\(\\beta\\)), ocorrendo na segunda amostra (\\(1-\\beta\\)). Desta forma, \\(0.9436^1(1-0.9436) = 0.0532\\), resultando em uma probabilidade de 5,32%. Na terceira, a probabilidade é dada por \\(\\beta^2(1-\\beta)\\), isto é, \\(0.9436^2(1-0.9436) = 0.0502\\) ou 5,02%. Seguindo progressivamente a mesma lógica, a probabilidade de captar a oscilação da média na \\(r\\)-ésima amostra pode ser generalizada por\n\\[\n\\beta^{r-1}(1-\\beta).\n\\]\nBuscando conhecer número médio de amostras coletadas até que um sinal seja emitido pelo gráfico de controle \\(\\bar{X}\\), podemos descrever o quantitativo por meio de um somatório de \\(\\beta\\), de tal forma que\n\\[\n\\sum_{i=1}^\\infty \\beta^{r=1}(1-\\beta) = \\dfrac{1}{1-\\beta} = ARL.\n\\]\nEssa medida é denominada Comprimento Médio de Sequência (ARL1), sendo utilizada para subsidiar decisões relativas ao tamanho da amostra e à frequência de amostragem. Na prática, indica quantos pontos de um processo consegue registrar antes que o gráfico aponte uma possível alteração ou desvio, seja ele dentro de controle (\\(ARL_0\\)) ou fora de controle (\\(ARL_1\\)).\nTomando como cenário um processo em \\(3\\sigma\\) sob controle, o risco de pontos fora de controle (erro tipo I) é de \\(0.0027\\). Logo, podemos calcular\n\nCódigo\nARL_0 =  1 / 0.0027\nround(ARL_0, 2)\n\n[1] 370.37\nsignificando dizer que o processo acusará um alarme falso, em média, a cada 370 amostras. Em um caso alternativo, onde um processo com \\(n=5\\) amostras coletadas tenha sofrido alguma alteração em sua média, o \\(ARL_1\\) é dado por \\[\nARL_1 = \\dfrac{1}{1-\\beta} = \\dfrac{1}{1 - \\left\\{ \\Phi \\left[L - k\\sqrt{n}\\right] - \\Phi \\left[-L - k\\sqrt{n}\\right] \\right\\}}.\n\\]\n\nRPython\n\n\n\n\nCódigo\narl_1 =  1 / (1 - pnorm(3 - 1*sqrt(5)) - pnorm(-3 - 1*sqrt(5)))\nround(arl_1, 2)\n\n\n[1] 4.5\n\n\n\n\n\n\nCódigo\narl_1 =  1 / (1 - norm.cdf(3 - 1*np.sqrt(5)) - norm.cdf(-3 - 1*np.sqrt(5)))\nprint(round(arl_1, 2))\n\n\n4.5\n\n\n\n\n\nPortanto, são necessárias aproximadamente cinco amostras coletadas para detecção de uma mudança de \\(1\\sigma\\) (\\(k=1\\)).\nPara a construção do gráfico de ARL considerando diferentes tamanhos de amostra (\\(n\\)) e de deslocamentos da média (\\(k\\)), temos que considerar o caso de ocorrência de pontos fora de controle (\\(ARL_1\\)).\n\nRPython\n\n\n\n\nCódigo\nL = 3                             # Nível do processo \nk = seq(0, 5, length.out = 100)   # Valores para deslocamento\n\n# Comprimento Médio de Sequência\nARL1 =  1 / (1 - (pnorm(L - k*sqrt(1)) - pnorm(-L - k*sqrt(1))))\nARL2 =  1 / (1 - (pnorm(L - k*sqrt(2)) - pnorm(-L - k*sqrt(2))))\nARL5 =  1 / (1 - (pnorm(L - k*sqrt(5)) - pnorm(-L - k*sqrt(5))))\nARL10 =  1 / (1 - (pnorm(L - k*sqrt(10)) - pnorm(-L - k*sqrt(10))))\nARL20 =  1 / (1 - (pnorm(L - k*sqrt(20)) - pnorm(-L - k*sqrt(20))))\n\n# Gráfico comparativo das Curvas\npar(mfrow = c(1, 1))\nplot(k, ARL1, type = \"l\", lwd = 1.25, lty=1, col = \"black\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, ARL2, type = \"l\", lwd = 1.25, lty=1, col = \"red\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, ARL5, type = \"l\", lwd = 1.25, lty=1, col = \"green\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, ARL10, type = \"l\", lwd = 1.25, lty=1, col = \"blue\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, ARL20, type = \"l\", lwd = 1.25, lty=1, col = \"purple\", axes=T,\n    xlab = \"Deslocamento da Média (k)\",\n    ylab = \"Comprimento Médio de Sequência (ARL)\",\n    main = \"Comprimento Médio de Sequência vs. Deslocamento da Média\",\n    ylim=c(0,400))\naxis(1)\naxis(2)\ngrid()\nlegend(\"topright\", title=\"Amostras\", lwd = 1.25, lty = 1,\n     legend = c(\"n = 1\", \"n = 2\", \"n = 5\", \"n = 10\", \"n = 20\"),  \n     col = c(\"black\", \"red\", \"green\", \"blue\", \"purple\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\nL = 3                       # Nível do processo \nk = np.linspace(0, 5, 100)  # Valores para deslocamento\n\n# Comprimento Médio de Sequência\nARL1 = 1 / (1 - (norm.cdf(L - k*np.sqrt(1)) - norm.cdf(-L - k*np.sqrt(1))))\nARL2 = 1 / (1 - (norm.cdf(L - k*np.sqrt(2)) - norm.cdf(-L - k*np.sqrt(2))))\nARL5 = 1 / (1 - (norm.cdf(L - k*np.sqrt(5)) - norm.cdf(-L - k*np.sqrt(5))))\nARL10 = 1 / (1 - (norm.cdf(L - k*np.sqrt(10)) - norm.cdf(-L - k*np.sqrt(10))))\nARL20 = 1 / (1 - (norm.cdf(L - k*np.sqrt(20)) - norm.cdf(-L - k*np.sqrt(20))))\n\n# Gráfico comparativo das Curvas\nplt.plot(k, ARL1, linewidth = .75, color = \"black\", label = 'n = 1')\nplt.plot(k, ARL2, linewidth = .75, color = \"red\", label = 'n = 2')\nplt.plot(k, ARL5, linewidth = .75, color = \"green\", label = 'n = 5')\nplt.plot(k, ARL10, linewidth = .75, color = \"blue\", label = 'n = 10')\nplt.plot(k, ARL20, linewidth = .75, color = \"purple\", label = 'n = 20')\nplt.xlabel('Deslocamento da Média (k)')\nplt.ylabel('Comprimento Médio de Sequência (ARL)')\nplt.title('Comprimento Médio de Sequência vs. Deslocamento da Média')\nplt.ylim(0,400)\n\n\n(0.0, 400.0)\n\n\nCódigo\nplt.legend(title='Amostras', fontsize=9)\nplt.grid(True, alpha=.3)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html#curva-característica-de-operação-cco-cdot-r",
    "href": "C3_CCO_CMS.html#curva-característica-de-operação-cco-cdot-r",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "3.4 Curva Característica de Operação (CCO \\(\\cdot R\\))",
    "text": "3.4 Curva Característica de Operação (CCO \\(\\cdot R\\))\nAo contrário da média, o gráfico de amplitude não apresenta uma distribuição simétrica, mesmo que a amostragem seja feita a partir de uma normalidade. Isso significa dizer que em um nível de operação de \\(3\\sigma\\) o risco \\(\\alpha\\) é diferente de \\(0.0027\\), resultante para a média.\nPara a construção da CCO para o gráfico de amplitude, considera-se um intervalo relativo definido por \\(W=R/\\sigma\\), com suas propriedades de média (\\(E(W)=d_2\\)) e desvio-padrão (\\(\\sigma_W=d_3\\)). Supondo que os valores dentro dos limites de controle tenham um desvio \\(\\sigma_0\\) e a oscilação do gráfico tenha resultado em um novo desvio \\(\\sigma_1\\), o risco \\(\\beta\\) é dado em função da razão dos desvios (\\(\\sigma_1&gt;\\sigma_0 \\Rightarrow \\sigma_1 / \\sigma_0 &gt; 1\\)).\nDesta forma, o risco \\(\\beta\\) para um dado desvio \\(\\sigma\\), em termos de amplitude, de um nível \\(\\sigma_0\\) mudar para \\(\\sigma_1\\), sendo \\(\\sigma_1 = \\lambda\\sigma_0\\), pode ser descrito como\n\\[\\beta = P \\left[ LIC \\leq R \\leq LSC | \\sigma_1 = \\lambda\\sigma_0 \\right]. \\]\nConsiderando os limites inferior e superior de controle como \\(LIE = D_3 \\bar{R} = D_3\\cdot d_2 \\cdot \\sigma_0\\) e \\(LSE = D_4 \\bar{R} = D_4\\cdot d_2 \\cdot \\sigma_0\\), respectivamente, podemos fazer os ajustes, de tal forma que\n\\[\n\\beta = P \\left[ D_3\\cdot d_2 \\cdot \\sigma_0 \\leq R \\leq D_4\\cdot d_2 \\cdot \\sigma_0 | \\sigma_1 = \\lambda\\sigma_0 \\right].\n\\]\nDividindo todos os termos da expressão por \\(\\sigma_1\\), temos que\n\\[\n\\beta = P \\left[ \\dfrac{D_3 d_2}{\\lambda} \\leq W \\leq \\dfrac{D_4 d_2}{\\lambda} \\right],\n\\]\nonde \\(\\lambda\\) representa a razão entre os desvios (\\(\\lambda = \\sigma_1 / \\sigma_0\\)).\nFazendo a aproximação pela distribuição normal da medida relativa \\(W \\sim N(d_2, d_3^2)\\) com os respectivos limites de controle, os termos podem ser trabalhados em termos de função de distribuição cumulativa normal \\(\\Phi(\\cdot)\\). Desta forma, a função \\(\\beta\\) pode ser expressa como \\[ \\beta = \\Phi \\left[\\dfrac{\\dfrac{D_4 d_2}{\\lambda}-d_2}{d_3}\\right] - \\Phi \\left[\\dfrac{\\dfrac{D_3 d_2}{\\lambda}-d_2}{d_3}\\right].\n\\]\nProgressivamente, a construção das CCOs para diferentes números de amostra depende do cruzamento entre o risco \\(\\beta\\) e a distância entre os desvios (\\(\\lambda\\)).\n\nRPython\n\n\n\nCódigo\n# Valores tabelados para d2, d3, D3 e D4\nd2 = c(1.128, 2.326, 3.078, 3.735)\nd3 = c(0.853, 0.864, 0.797, 0.729)\nD3 = c(0,0,0.223, 0.415)\nD4 = c(3.267, 2.115, 1.777, 1.585)\n\n# Diferentes valores para lambda (σ1/σ0)\nlambda = seq(1,6, length.out=100)\n\n# Cálculo de valores para beta\nbetal_2 = pnorm(((D4[1] * d2[1] / lambda) - d2[1]) / d3[1]) - pnorm(((D3[1] * d2[1] / lambda) - d2[1]) / d3[1])\nbetal_5 = pnorm(((D4[2] * d2[2] / lambda) - d2[2]) / d3[2]) - pnorm(((D3[2] * d2[2] / lambda) - d2[2]) / d3[2])\nbetal_10 = pnorm(((D4[3] * d2[3] / lambda) - d2[3]) / d3[3]) - pnorm(((D3[3] * d2[3] / lambda) - d2[3]) / d3[3])\nbetal_20 = pnorm(((D4[4] * d2[4] / lambda) - d2[4]) / d3[4]) - pnorm(((D3[4] * d2[4] / lambda) - d2[4]) / d3[4])\n\n# Gráfico CCO -- R-bar\n# Gráfico comparativo das Curvas\npar(mfrow = c(1, 1))\nplot(lambda, betal_2, type = \"l\", lwd = 1.25, lty=1, \n     col = \"red\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(lambda, betal_5, type = \"l\", lwd = 1.25, lty=1, \n     col = \"green\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(lambda, beta_10, type = \"l\", lwd = 1.25, lty=1, \n     col = \"blue\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(lambda, betal_20, type = \"l\", lwd = 1.25, lty=1, \n     col = \"purple\", axes=T,\n     xlab = expression(\"Razão dos desvios \" (lambda == frac(sigma[1], sigma[0]))),\n     ylab = \"Risco do Consumidor (β)\",\n     main = \"Curva Característica de Operação -- Gráfico R-bar\",\n     ylim = c(0,1))\ngrid()\nlegend(\"topright\", title=\"Amostras\", lwd = 1.25, lty = 1,\n     legend = c(\"n = 2\", \"n = 5\", \"n = 10\", \"n = 20\"),  \n     col = c(\"red\", \"green\", \"blue\", \"purple\"))\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# Valores tabelados para d2, d3, D3 e D4\nd2 = [1.128, 2.326, 3.078, 3.735]\nd3 = [0.853, 0.864, 0.797, 0.729]\nD3 = [0,0,0.223, 0.415]\nD4 = [3.267, 2.115, 1.777, 1.585]\n\n# Diferentes valores para lambda (σ1/σ0)\nlambdas= np.linspace(1, 6, 100) \n\n# Cálculo de valores para beta\nbetal_2 = norm.cdf(((D4[0] * d2[0] / lambdas) - d2[0]) / d3[0]) - norm.cdf(((D3[0] * d2[0] / lambdas) - d2[0]) / d3[0])\nbetal_5 = norm.cdf(((D4[1] * d2[1] / lambdas) - d2[1]) / d3[1]) - norm.cdf(((D3[1] * d2[1] / lambdas) - d2[1]) / d3[1])\nbetal_10 = norm.cdf(((D4[2] * d2[2] / lambdas) - d2[2]) / d3[2]) - norm.cdf(((D3[2] * d2[2] / lambdas) - d2[2]) / d3[2])\nbetal_20 = norm.cdf(((D4[3] * d2[3] / lambdas) - d2[3]) / d3[3]) - norm.cdf(((D3[3] * d2[3] / lambdas) - d2[3]) / d3[3])\n\n# Gráfico CCO -- R-bar\n# Gráfico comparativo das Curvas\nplt.plot(lambdas, betal_2, linewidth = .75, color = \"red\", label = 'n = 2')\nplt.plot(lambdas, betal_5, linewidth = .75, color = \"green\", label = 'n = 5')\nplt.plot(lambdas, betal_10, linewidth = .75, color = \"blue\", label = 'n = 10')\nplt.plot(lambdas, betal_20, linewidth = .75, color = \"purple\", label = 'n = 20')\nplt.xlabel(r'Razão dos desvios $\\lambda = \\sigma_1/\\sigma_0$')\nplt.ylabel('Risco do Consumidor (β)')\nplt.title('Comprimento Médio de Sequência vs. Deslocamento da Média')\nplt.ylim(0,1)\n\n\n(0.0, 1.0)\n\n\nCódigo\nplt.legend(title='Amostras', fontsize=9)\nplt.grid(True, alpha=.3)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nNota-se que a CCO \\(\\cdot R\\) não demonstra bons resultados na detecção de mudanças para valores pequenos de amostra. Isso pode ser observado comparando os casos de \\(n=2\\) e \\(n=20\\); se o desvio padrão do processo dobrar (isto é, \\(\\lambda = \\sigma_1/\\sigma_0 = 2\\)), o primeiro caso tem cerca de 30% de chance em detectar a mudança na amostra subsequente; já no segundo caso, a chance alcança 90%. Por esse motivo, a literatura recomenda o uso do gráfico \\(R\\) para subamostras racionais maiores que 10 (Montgomery 2012).\n\n\n\n\n\n\n\n\n\n\n\nBotter, Denise Aparecida. 2013. «Inspeção de Qualidade». Notas de Aula. https://www.ime.usp.br/~botter/mae532/Inspecao.pdf.\n\n\nCarpinetti, Luiz C. R. 2003. Controle da Qualidade de Processo. 2.ª ed. Universidade de São Paulo.\n\n\nMontgomery, Douglas C. 2012. Statistical Quality Control. 7.ª ed. John Wiley & Sons.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html#footnotes",
    "href": "C3_CCO_CMS.html#footnotes",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "",
    "text": "acrônimo em inglês para Average Run Length↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html",
    "href": "C4_PlotOfAtributes.html",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "",
    "text": "4.1 Introdução",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html#gráficos-de-controle-para-p",
    "href": "C4_PlotOfAtributes.html#gráficos-de-controle-para-p",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "4.2 Gráficos de Controle para \\(p\\)",
    "text": "4.2 Gráficos de Controle para \\(p\\)\nO gráfico \\(p\\) é uma ferramenta destinada ao monitoramento da proporção de unidades defeituosas em um processo produtivo. Esse gráfico é particularmente útil quando a característica de qualidade em estudo pode ser classificada de forma binária, isto é, como “defeituoso” ou “não defeituoso”.\nPara cada amostra coletada é calculada a fração amostral não conforme, definida como a razão entre o número de unidades não conformes (ou seja, unidades defeituosas) na amostra \\(D_i\\) e o tamanho \\(n\\) da amostra, isto é, \\[\\hat{p_i} = \\frac{D_i}{n}\\] Sendo assim, a linha central para o gráfico \\(p\\) é dada por \\(\\hat{p}\\) e os limites para o gráfico (±3\\(\\sigma\\)) são dados por: \\[LIC = \\hat{p} - 3\\sqrt\\frac{\\hat{p}(1 - \\hat{p})}{n}\\] \\[LSC = \\hat{p} + 3\\sqrt\\frac{\\hat{p}(1 - \\hat{p})}{n}\\]\n\n4.2.1 Exemplo\nSelecionadas 19 amostras de tamanho \\(n\\) = 50, temos que:\n\n\nCódigo\ndados &lt;- data.frame(\n  Amostra = 1:19,\n  Di = c(5, 15, 10, 4, 3, 20, 11, 9, 3, 20, 11, 6, 7, 11, 3, 3, 9, 3, 8),\n  pi = c(0.1, 0.3, 0.2, 0.08, 0.06, 0.4, 0.22, 0.18, 0.06, 0.4, 0.22, 0.12, 0.14, 0.22, 0.06, 0.06, 0.18, 0.06, 0.16)\n)\n\n# Proporção média\np_barra &lt;- mean(dados$pi)\np_barra\n\n\n[1] 0.1694737\n\n\nCódigo\n#Cálculo dos limites\nLSC = p_barra + 3*sqrt((p_barra*(1-p_barra))/50)\nLC = p_barra\nLIC = p_barra - 3*sqrt((p_barra*(1-p_barra))/50)\n\ncbind(LSC, LIC, LC)\n\n\n           LSC        LIC        LC\n[1,] 0.3286447 0.01030263 0.1694737\n\n\n\n4.2.1.1 Gráfico\n\n\nCódigo\nplot(dados$pi, type = \"b\", pch = 19, ylim = c(0, max(LSC, max(dados$pi))),\n     col = \"black\",\n     main = \"Gráfico p\",\n     ylab = \"Fração não-conforme\", xlab = \"Amostra\")\n\nabline(h = c(LSC, LC, LIC), col = c(\"red\", \"blue\", \"red\"), \n       lty = c(2,2,2), lwd = 2)\n\n# Legenda\nlegend(\"topright\", legend = c(\"p\", \"p-barra\", \"LIC/LSC\"),\n       col = c(\"black\", \"blue\", \"red\"), lty = c(1,2,2), pch = c(16, NA, NA))\n\n\n\n\n\n\n\n\n\nÉ possível notar no gráfico que as amostras 6 e 10 ultrapassam o limite superior de controle, portanto, estão, estatísticamente, fora de controle.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html#gráficos-de-controle-para-np",
    "href": "C4_PlotOfAtributes.html#gráficos-de-controle-para-np",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "4.3 Gráficos de Controle para \\(np\\)",
    "text": "4.3 Gráficos de Controle para \\(np\\)\nEm determinados processos, os itens produzidos podem apresentar certo número de pequenas não conformidades que não o caracterizem como um item não conforme. No entanto, pequenas não conformidades em excesso pode ser perceptível (e indesejável) ao consumidor.\nO gráfico \\(np\\) tem por objetivo o monitoramento do número de itens defeituosos em uma linha de produção, detectando possíveis problemas no processo quando há extrapolação dos limites de controle.\n\n4.3.1 Gráfico \\(np\\) com Subgrupos Fixos\nQuando o número de amostras coletadas é fixa ao longo do tempo, seus limites de controle e de advertência também o serão. Desta forma, os limites de controle do gráfico \\(p\\) com nível de operação \\(3\\sigma\\) (\\(L=3\\)) são adaptados de tal forma que\n\\[\nLIC = \\left\\{ \\begin{array} n\\bar{p} -3\\sqrt{n\\bar{p}\\cdot(1-\\bar{p})}, \\text{ se } LIC &gt; 0; \\\\ 0, \\text{ caso contrário.} \\end{array} \\right .\n\\]\nrepresenta as condições do limite inferior de controle,\n\\[\nLC = n\\bar{p}\n\\]\nrepresenta o limite central e\n\\[\nLSC = n\\bar{p} + 3 \\sqrt{n\\bar{p}\\cdot(1-\\bar{p})}\n\\]\nrepresenta o limite superior de controle.\nA construção da carta de controle \\(np\\) considera o número de defeitos constados em cada amostra e, baseado nele, é calculado a proporção de defeitos. É possível a determinação de zonas de alerta, onde o processo ainda não sofreu efetivo descontrole, porém é dado um sinal de aviso. O processo deve ser monitorado com maior cautela em casos de tendência ou variações cíclicas e sucessivas.\nPara contextualização o gráfico abaixo representa uma linha de produção com controle realizado feito a partir de \\(n=50\\) itens em cada amostra, com número de defeitos representado por \\(D_i\\).\n\nRPython\n\n\n\n\nCódigo\n# Carregar pacote\nif (!require(glue)) install.packages(\"glue\")\nlibrary(glue)\n\n# Número de não-conformidades\nset.seed(123) # para reprodutibilidade\nD_i &lt;- rbinom(20, 50, 0.1235)\nn &lt;- 50\n\nmedia_p &lt;- mean(D_i / n)\n\n# Valores de interesse\nlc &lt;- n * media_p\nlsc &lt;- n * media_p + 3 * sqrt(n * media_p * (1 - media_p))\nlic &lt;- n * media_p - 3 * sqrt(n * media_p * (1 - media_p))\n\n# Evitar limites negativos\nlic &lt;- max(0, lic)\n\n# Valores de alerta (2σ)\nlsc_a &lt;- n * media_p + 2 * sqrt(n * media_p * (1 - media_p))\nlic_a &lt;- n * media_p - 2 * sqrt(n * media_p * (1 - media_p))\nlic_a &lt;- max(0, lic_a)\n\n# Gráfico np\nplot(1:10, 1:10, type = \"n\", xlab = '', ylab = '',\n     ylim = c(lic * 0.75, lsc * 1.15),\n     xlim = c(1, 20))  # &lt;-- parêntese corrigido\n\n# Zona de alerta\nrect(ybottom = lic_a, ytop = lsc_a, xleft = 0, xright = 20,\n     col = rgb(248/255, 238/255, 153/255, alpha = .30), border = NA)\n\n# Sobreposição da série\npar(new = TRUE)\nplot(D_i, lty = 1, lwd = 1.25, pch = 19, cex = 1.15, type = 'b',\n     ylim = c(lic * 0.75, lsc * 1.15), xlim = c(1, 20),\n     col = '#096CC8', xlab = 'Amostra', ylab = 'Número de não-conformes',\n     main = 'Gráfico np')\naxis(side = 1, at = 1:20, labels = 1:20)\n\n# Linhas de controle\nabline(h = c(lsc, lc, lic),\n       col = c('#CD5C5C', '#8FC6FA', '#CD5C5C'),\n       lty = c(2, 1, 2), lwd = 1.25)\n\n# Textos\ntext(x = c(1, 1, 1, 18),\n     y = c(lic * 1.15, lc * 1.05, lsc * 0.98, lsc_a * 0.98),\n     labels = c(glue(\"LIC = {sprintf('%.4f', lic)}\"),\n                glue(\"LC = {sprintf('%.4f', lc)}\"),\n                glue(\"LSC = {sprintf('%.4f', lsc)}\"),\n                'Zona de Alerta'),\n     col = c('#CD5C5C', '#8FC6FA', '#CD5C5C', '#BCAA01'),\n     cex = .75)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport pandas as pd\nimport random\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Geração de dados\n#random.seed(1236)\nn = 50\n#D_i = list(np.random.normal(loc=15, scale=3, size=25)\n# Número de não-conformidades\nD_i = [12, 14, 14, 18, 10, 16, 11, 19, 12, 17, 20, 20, 18, 14, 19, 14, 16, 15, 13, 14, 15, 14, 20, 14, 17]\np_i = [x / n for x in D_i]\n\n# União de dados em um dataframe\ndados = pd.DataFrame({'Amostra': list(range(1,len(D_i)+1)), 'D_i': D_i, 'p_i': p_i})\n\n# Média das proporções\nmedia_p = dados['p_i'].mean()\n\n# Valores de interesse\nlc = n*media_p\nlsc = n*media_p + 3*np.sqrt(n*media_p*(1 - media_p))\nlic = n*media_p - 3*np.sqrt(n*media_p*(1 - media_p))\n\n# Valores de alerta (2σ)\nlsc_a = n*media_p + 2*np.sqrt(n*media_p*(1 - media_p))\nlic_a = n*media_p - 2*np.sqrt(n*media_p*(1 - media_p))\n\n# Gráfico np\nplt.figure(figsize=(16,6))\nplt.plot(dados['D_i'], color='#096CC8', marker='o', linestyle='-', linewidth=0.9, markersize = 6)\n\n# Plotagem das Linhas dos Limites de Controle\nplt.axhline(y=lc, color='#8FC6FA', linestyle='-', linewidth = 1.1, label='LC')\nplt.axhline(y=lsc, color='#CD5C5C', linestyle='--', label=f'LSC = {lsc:.4f}')\nplt.axhline(y=lic, color='#CD5C5C', linestyle='--', label='LIC')\n\n# Anotação dos Limites de Controle\nplt.annotate(f'LC = {lc:.4f}', xy=(0, lc), xytext=(0, lc*1.05), color='#2471a3')\nplt.annotate(f'LSC= {lsc:.4f}', xy=(0, lsc), xytext=(0, lsc*0.95), color='#CD5C5C')\nplt.annotate(f'LIC = {lic:.4f}', xy=(0, lic), xytext=(0, lic*1.15), color='#CD5C5C')\n\n# Zona de alerta\nplt.axhspan(ymin=lic_a, ymax=lsc_a, alpha=0.3, color ='#F8EE99', label = 'Zona de Alerta')\nplt.annotate('Zona de Alerta', xy=(len(dados)*.9, lsc_a), xytext=(len(dados)*.9, lsc_a*.96), color='#BCAA01')\n\n# Identificação dos eixos\nplt.title('Gráfico de Controle np', fontsize=14)\nplt.xlabel('Amostra')\nplt.ylabel('Número de Não-Conformidades')\nplt.ylim(0, lsc*1.15)\n\n\n(0.0, 29.026536966799764)\n\n\nCódigo\nplt.xticks(ticks=range(len(dados)), labels=dados['Amostra'])\n\n\n([&lt;matplotlib.axis.XTick object at 0x000002624CAE2F90&gt;, &lt;matplotlib.axis.XTick object at 0x000002624C789160&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB47650&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB06F60&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB05760&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB447A0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CAF7DA0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB60830&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB612E0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB46CF0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB61D30&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB62720&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB630B0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB63A70&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB62060&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB904D0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB90F20&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB919A0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB923C0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB90BF0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB92C30&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB93680&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB93D10&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB93D40&gt;, &lt;matplotlib.axis.XTick object at 0x000002624CB91E50&gt;], [Text(0, 0, '1'), Text(1, 0, '2'), Text(2, 0, '3'), Text(3, 0, '4'), Text(4, 0, '5'), Text(5, 0, '6'), Text(6, 0, '7'), Text(7, 0, '8'), Text(8, 0, '9'), Text(9, 0, '10'), Text(10, 0, '11'), Text(11, 0, '12'), Text(12, 0, '13'), Text(13, 0, '14'), Text(14, 0, '15'), Text(15, 0, '16'), Text(16, 0, '17'), Text(17, 0, '18'), Text(18, 0, '19'), Text(19, 0, '20'), Text(20, 0, '21'), Text(21, 0, '22'), Text(22, 0, '23'), Text(23, 0, '24'), Text(24, 0, '25')])\n\n\nCódigo\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nA partir do gráfico acima podemos concluir pela estabilidade do processo, com linha central em \\(LC = 15,44\\), limites de alerta (\\(2\\sigma\\)) em \\(\\{LIA; LSA\\} = \\{5,6395; 25,2405\\}\\) e limites de controle em \\(\\{LIC; LSC\\} = \\{8,9064; 21,97364\\}\\). Nota-se que não há pontos fora da zona de alerta e todos os pontos das \\(m=25\\) amostras retiradas não apresentam sinais de tendência ou ciclidade.\n\n\n4.3.2 Gráfico \\(np\\) com Subgrupos Variáveis\nNa ocorrência de amostras de tamanho variável, sendo \\(n_j = 1,2,\\dots,m\\), os limites de controle se adequam ao tamanho amostral individual. Desta forma, os limites para um processo em \\(3\\sigma\\) são expressos por\n\\[\nLIC = \\left\\{ \\begin{array} nn_j\\bar{p} -3\\sqrt{n_j\\bar{p}\\cdot(1-\\bar{p})}, \\text{ \\hspace{.5cm} se \\hspace{.25cm}} LIC &gt; 0; \\\\ 0, \\text{ \\hspace{5.1cm} caso contrário.} \\end{array} \\right .\n\\]\nrepresentando as condições do limite inferior de controle, \\[\nLC = n_j\\bar{p}\n\\] representa o limite central e \\[\nLSC = n_j\\bar{p} + 3 \\sqrt{n_j\\bar{p}\\cdot(1-\\bar{p})}\n\\] representa o limite superior de controle.\nA construção do gráfico considera o número variável do tamanho amostral (\\(n\\)), gerando, portanto, limites de controle e de alerta flutuantes. A carta abaixo considerou dimensões de amostra entre 48 e 52 unidades em cada retirada.\n\nRPython\n\n\n\n\nCódigo\nrequire(glue)\nset.seed(1236)\nn_j = sample(48:52, 25, replace=TRUE)       # Subgrupos variáveis\nD_i = round(rnorm(n=25, mean=15, sd=3),0)\np_i = D_i / n_j\n\n# União de dados em um dataframe\ndados = data.frame(Amostra=1:length(D_i), D_i=D_i, n_j=n_j, p_i=p_i)\n\n# Média das proporções\nmedia_p = mean(dados$p_i)\n\n# Valores de interesse\nlc = n_j*media_p\nlsc = n_j*media_p + 3*sqrt(n_j*media_p*(1 - media_p))\nlic = n_j*media_p - 3*sqrt(n_j*media_p*(1 - media_p))\n\n# Valores de alerta (2σ)\nlsc_a = n_j*media_p + 2*sqrt(n_j*media_p*(1 - media_p))\nlic_a = n_j*media_p - 2*sqrt(n_j*media_p*(1 - media_p))\n\n# Gráfico np\npar(mfrow = c(1, 1))\nplot(dados$D_i, lty = 1, lwd=1.25, pch=19, cex=1.15, type='b',\n    xlim = c(1, nrow(dados)), ylim = c(min(lic)*0.75,max(lsc)*1.1),\n    col='#096CC8', xlab='Amostra', ylab='Número de não-conformes',\n    main = 'Gráfico np')\naxis(side = 1, at = dados$Amostra, labels=dados$Amostra)\n\n# Plotagem das Linhas dos Limites de Controle\nlines(x=dados$Amostra, y = lc, col = '#8FC6FA', lty=1, lwd=1.25)\nlines(x=dados$Amostra, y = lsc, col= '#CD5C5C', lty = 2, lwd = 1.25)\nlines(x=dados$Amostra, y = lic, col='#CD5C5C', lty = 2, lwd = 1.25)\n\n# Plotagem das Linhas de Alerta\nlines(x=dados$Amostra, y = lsc_a, col= '#BCAA01', lty = 2, lwd = 1.5)\nlines(x=dados$Amostra, y = lic_a, col= '#BCAA01', lty = 2, lwd = 1.5)\n\n# Configuração das legendas\nlegend(x='topleft',legend = c(\"LIC\", \"LC\", \"LSC\"), col=c('#CD5C5C','#8FC6FA','#CD5C5C'), \n    lty=c(2,1,2), lwd=1.25, cex=.75, horiz=TRUE, title='Limites de Controle')\nlegend(x='topright', legend = c(\"LIA\", \"LSA\"), col='#BCAA01', \n    lty=2, lwd=1.5, cex=.75, horiz=TRUE, title='Zona de Alerta (2σ)')\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport warnings\nwarnings.filterwarnings('ignore')\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nn_j = [51,48,48,50,48,50,51,50,49,50,51,52,52,50,50,48,49,48,48,52,48,52,49,50,49]\nD_i = [12,14,14,18,10,16,11,19,12,17,20,20,18,14,19,14,16,15,13,14,15,14,20,14,17]\np_i = [x / y for x, y in zip(D_i, n_j)]\n\n# União de dados em um dataframe\ndados = pd.DataFrame({'Amostra': list(range(1,len(D_i)+1)), 'D_i': D_i, 'n_j':n_j, 'p_i': p_i})\n\n# Média das proporções\nmedia_p = dados['p_i'].mean().round(4)\n\n# Valores de interesse\nlic = dados['n_j']*media_p - 3*np.sqrt(dados['n_j']*media_p*(1 - media_p))\nlc = dados['n_j']*media_p\nlsc = dados['n_j']*media_p + 3*np.sqrt(dados['n_j']*media_p*(1 - media_p))\n\n\n# Valores de alerta (2σ)\nlsc_a = dados['n_j']*media_p + 2*np.sqrt(dados['n_j']*media_p*(1 - media_p))\nlic_a = dados['n_j']*media_p - 2*np.sqrt(dados['n_j']*media_p*(1 - media_p))\n\n# Gráfico np\nplt.figure(figsize=(16,6))\nplt.plot(dados['D_i'], color='#096CC8', marker='o', linestyle='-', linewidth=0.9, markersize = 6)\n\n# Plotagem das Linhas dos Limites de Controle\nplt.plot(lc, color='#8FC6FA', linestyle='-', linewidth = 1.1, label='LC')\nplt.plot(lsc, color='#CD5C5C', linestyle='--', label=f'LSC')\nplt.plot(lic, color='#CD5C5C', linestyle='--', label='LIC')\n\n# Plotagem das Linhas de Alerta\nplt.plot(lsc_a, color='#BCAA01', linestyle='--', label=f'LSA')\nplt.plot(lic_a, color='#BCAA01', linestyle='--', label=f'LIA')\nplt.legend(title='Limites de Controle')\n\nplt.ylim([0, np.max(lsc)*1.15])\n\n\n(0.0, 30.065050709186004)\n\n\nCódigo\nplt.xticks(ticks=range(len(dados)), labels=dados['Amostra'])\n\n\n([&lt;matplotlib.axis.XTick object at 0x000002624E38C6B0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E351F70&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E3F6C90&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E3F7680&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E3A2780&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E3F61E0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E3F4680&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E424440&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E424DA0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E3F6F90&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E425220&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E425C70&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E426660&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E4270B0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E426270&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E427A10&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43C410&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43CD70&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43D760&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43CFB0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43DFD0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43EA20&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43F4A0&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43FF20&gt;, &lt;matplotlib.axis.XTick object at 0x000002624E43DAF0&gt;], [Text(0, 0, '1'), Text(1, 0, '2'), Text(2, 0, '3'), Text(3, 0, '4'), Text(4, 0, '5'), Text(5, 0, '6'), Text(6, 0, '7'), Text(7, 0, '8'), Text(8, 0, '9'), Text(9, 0, '10'), Text(10, 0, '11'), Text(11, 0, '12'), Text(12, 0, '13'), Text(13, 0, '14'), Text(14, 0, '15'), Text(15, 0, '16'), Text(16, 0, '17'), Text(17, 0, '18'), Text(18, 0, '19'), Text(19, 0, '20'), Text(20, 0, '21'), Text(21, 0, '22'), Text(22, 0, '23'), Text(23, 0, '24'), Text(24, 0, '25')])\n\n\nCódigo\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nQuando trabalhamos com limites variáveis, há uma sensibilidade maior em detectar pontos de atenção e pontos fora de controle, dado que amostras menores tendem a indicar proporcionalmente mais defeitos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html#gráficos-de-controle-para-c",
    "href": "C4_PlotOfAtributes.html#gráficos-de-controle-para-c",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "4.4 Gráficos de Controle para \\(c\\)",
    "text": "4.4 Gráficos de Controle para \\(c\\)\nSegundo Montgomery, um item pode conter mais de um tipo de defeito de fabricação (não-conformidades) dependendo da sua natureza e severidade. Há casos em que quando tem-se como interesse o monitoramento dos defeitos resultantes do processo, é preferível trabalhar com o número de defeitos ao invés da fração defeituosa, como por exemplo o número de defeitos em um equipamento eletrônico.\nO gráfico de controle do número de defeitos (gráfico C) mede o número de defeitos em uma amostra de tamanho constante ou uma",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html#gráficos-de-controle-para-u",
    "href": "C4_PlotOfAtributes.html#gráficos-de-controle-para-u",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "4.5 Gráficos de Controle para \\(u\\)",
    "text": "4.5 Gráficos de Controle para \\(u\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html",
    "href": "C5_IndCapacity.html",
    "title": "5  Índices de Capacidade",
    "section": "",
    "text": "5.1 Conceitos Fundamentais\nEste capítulo explora os índices de capacidade de processo — medidas que avaliam quão bem um processo produtivo se comporta em relação aos limites de especificação (tolerâncias), considerando tanto a variabilidade do processo quanto seu posicionamento (centralização) dentro da especificação.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#conceitos-fundamentais",
    "href": "C5_IndCapacity.html#conceitos-fundamentais",
    "title": "5  Índices de Capacidade",
    "section": "",
    "text": "Um processo está em controle estatístico quando sua variabilidade é estável ao longo do tempo, sem causas especiais (válido para aplicar índices de capacidade).\nA especificação de um produto define dois limites importantes:\n\\[\nLSL = \\text{Lower Specification Limit} \\quad\\text{e}\\quad USL = \\text{Upper Specification Limit}\n\\]\nEstes limites definem a faixa aceitável para a característica de qualidade \\(X\\).\nSeja \\(\\mu\\) a média do processo e \\(\\sigma\\) seu desvio-padrão (usualmente estimado a partir de dados em curto prazo / dentro de subgrupos), ou outro estimador apropriado dependendo da estabilidade do processo.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#principais-índices-cp-cpl-cpu-cpk",
    "href": "C5_IndCapacity.html#principais-índices-cp-cpl-cpu-cpk",
    "title": "5  Índices de Capacidade",
    "section": "5.2 Principais Índices: Cp, Cpl, Cpu, Cpk",
    "text": "5.2 Principais Índices: Cp, Cpl, Cpu, Cpk\n\n5.2.1 Definições\n\nCp (capacidade potencial, ou índice de capacidade do processo) avalia apenas a dispersão do processo em relação à tolerância, assumindo que o processo está centralizado dentro dos limites:\n\n\\[\nCp = \\frac{USL - LSL}{6\\,\\sigma}\n\\]\n\nCpu e Cpl (capacidade em lados individualizados, superior e inferior) medem quão distante está a média do processo do limite superior ou inferior:\n\n\\[\nCpu = \\frac{USL - \\mu}{3\\,\\sigma},\\qquad Cpl = \\frac{\\mu - LSL}{3\\,\\sigma}\n\\]\n\nCpk (índice de capacidade corrigido ou real) considera tanto a variabilidade quanto a centralização, definindo-se como:\n\n\\[\nCpk = \\min(Cpu,\\, Cpl)\n\\]\nEstas fórmulas supõem distribuição aproximadamente normal do processo, e uso de estimador de variabilidade adequado (dentro de subgrupos, quando aplicável).\n\n\n5.2.2 Relação entre Cp e Cpk\n\nSe o processo está bem centralizado (\\(\\mu \\approx (USL + LSL)/2\\)), então \\(Cpu \\approx Cpl\\) e \\(Cpk \\approx Cp\\).\nSe o processo está deslocado em direção a um dos limites, \\(Cpk &lt; Cp\\).\nCp avalia a capacidade potencial (se fosse centralizado); Cpk avalia a capacidade real.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#interpretação-de-valores",
    "href": "C5_IndCapacity.html#interpretação-de-valores",
    "title": "5  Índices de Capacidade",
    "section": "5.3 Interpretação de Valores",
    "text": "5.3 Interpretação de Valores\n\n\n\n\n\n\n\nFaixa de índice\nInterpretação comum\n\n\n\n\n\\(Cp, Cpk &lt; 1.00\\)\nProcesso não capaz: partes do produto ficarão fora das especificações se mantido o nível de variabilidade atual.\n\n\n\\(Cpk = 1.00\\)\nProcesso “barely capable”: ±3σ atinge exatamente os limites. Aproximadamente 0,27% fora de especificação se centrado.\n\n\n\\(Cpk ≈ 1.33\\)\nBoa prática — muitos padrões (ex: indústria automotiva) adotam esse valor como mínimo aceitável para processos maduros.\n\n\n\\(Cpk ≥ 1.67\\) ou mais\nExcelente capacidade / processo robusto, muito raramente gerando defeitos.\n\n\n\nAlém disso:\n\nComparar Cpu e Cpl ajuda identificar se o problema está com desvio em direção a LSL ou USL.\nAvaliar se Cp está significativamente maior que Cpk: indica que variabilidade pode estar ok, mas centralização está ruim.\nVerificar se o processo realmente está em estado de controle antes de usar esses índices; se não estiver, os resultados podem ser enganosos.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#fórmulas-completas",
    "href": "C5_IndCapacity.html#fórmulas-completas",
    "title": "5  Índices de Capacidade",
    "section": "5.4 Fórmulas Completas",
    "text": "5.4 Fórmulas Completas\nPara relembrar:\n\\[\n\\begin{aligned}\nCp &= \\frac{USL - LSL}{6 \\sigma} \\\\\nCpu &= \\frac{USL - \\mu}{3 \\sigma} \\\\\nCpl &= \\frac{\\mu - LSL}{3 \\sigma} \\\\\nCpk &= \\min(Cpu,\\, Cpl)\n\\end{aligned}\n\\]\nTambém há variantes:\n\nPp, Ppk: versões de longo prazo (“long term” ou “overall”) que usam estimadores de variabilidade diferentes (todos os dados, não só dentro de subgrupos). ([JMP][2])\nCpm, Cpmk: que incorporam penalidades se o processo não tiver exatamente um alvo (target) prescrito.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#cálculo-computacional-em-r",
    "href": "C5_IndCapacity.html#cálculo-computacional-em-r",
    "title": "5  Índices de Capacidade",
    "section": "5.5 Cálculo Computacional em R",
    "text": "5.5 Cálculo Computacional em R\nAqui vão exemplos práticos para cálculo de Cp, Cpk usando R, tanto para dados simulados quanto reais.\n\n5.5.1 Exemplo simples (dados simulados)\n\n\nCódigo\n# Simulação de dados\nset.seed(123)\nn &lt;- 1000\nmu_true &lt;- 50\nsigma_true &lt;- 2\ndados &lt;- rnorm(n, mean = mu_true, sd = sigma_true)\n\nUSL &lt;- 55\nLSL &lt;- 45\n\n# Estimadores\nmu_hat &lt;- mean(dados)\nsigma_hat &lt;- sd(dados)\n\nCp_hat &lt;- (USL - LSL) / (6 * sigma_hat)\nCpu_hat &lt;- (USL - mu_hat) / (3 * sigma_hat)\nCpl_hat &lt;- (mu_hat - LSL) / (3 * sigma_hat)\nCpk_hat &lt;- min(Cpu_hat, Cpl_hat)\n\n# Exibir resultados\ndata.frame(\n  Mu = mu_hat,\n  Sigma = sigma_hat,\n  Cp = Cp_hat,\n  Cpu = Cpu_hat,\n  Cpl = Cpl_hat,\n  Cpk = Cpk_hat\n)\n\n\n        Mu   Sigma        Cp       Cpu       Cpl       Cpk\n1 50.03226 1.98339 0.8403121 0.8348912 0.8457331 0.8348912\n\n\nInterpretação (exemplo):\n\nSe \\(Cp_hat = 1.25\\) mas \\(Cpk_hat = 0.90\\), indica que embora a variabilidade seja razoável, a média está deslocada para um dos limites.\nAjustes podem envolver centralizar o processo, reduzir variabilidade ou ajustar especificações, se possível.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#considerações-práticas",
    "href": "C5_IndCapacity.html#considerações-práticas",
    "title": "5  Índices de Capacidade",
    "section": "5.6 Considerações Práticas",
    "text": "5.6 Considerações Práticas\n\nDistribuição dos dados: muitos índices pressupõem normalidade. Se os dados forem muito assimétricos ou com caudas pesadas, pode ser necessário usar transformações ou índices específicos para não-normais.\nDados em controle: como mencionado, aplicar índices somente se o processo estiver estável em termos de variabilidade. Caso contrário, a estimativa de \\(\\sigma\\) será instável.\nTamanho da amostra e agrupamentos: estimadores de \\(\\sigma\\) “dentro-subgrupos” geralmente mais confiáveis para variação de curto prazo. Para longo prazo, use variabilidade global.\nUnilaterais vs bilaterais: quando só um limite de especificação é crítico (por exemplo só USL ou só LSL), índices como Cpu ou Cpl têm papel importante, ou índices modificados para tolerâncias unilaterais.\nMetas e padrões da indústria: muitos setores (por exemplo automotivo, aeroespacial) definem metas mínimas como \\(Cpk \\ge 1.33\\) ou maior, como parte de requisitos de qualidade.\nRelatórios e comunicação: além dos valores numéricos, apresentar gráficos (histograma com limites, densidade, overlay de especificação) ajuda na interpretação.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#exemplos-de-interpretação-e-decisão",
    "href": "C5_IndCapacity.html#exemplos-de-interpretação-e-decisão",
    "title": "5  Índices de Capacidade",
    "section": "5.7 Exemplos de Interpretação e Decisão",
    "text": "5.7 Exemplos de Interpretação e Decisão\n\nSe \\(Cp\\) é alto (digamos ≥ 1.50) mas \\(Cpk\\) é baixo (~0.90): indica que a causa principal do problema é centralização. Pode-se ajustar médio do processo (calibrar máquina, ajuste de parâmetros de operação) para mover a média para o centro.\nSe \\(Cpk\\) e \\(Cp\\) ambos baixos (&lt;1): ou variabilidade é grande demais ou processos instáveis — primeiro verificar fontes de variabilidade (equipamento, matéria-prima, ambiente, etc.), talvez mudar de processo ou especificação.\nSe o processo tem metas rígidas de qualidade ou segurança, mesmo \\(Cpk\\) ligeiramente acima de 1 pode ser insuficiente — verificar política da empresa ou cliente.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#extensões-e-índices-derivados",
    "href": "C5_IndCapacity.html#extensões-e-índices-derivados",
    "title": "5  Índices de Capacidade",
    "section": "5.8 Extensões e Índices Derivados",
    "text": "5.8 Extensões e Índices Derivados\n\nCpm, Cpmk: quando há um target (meta) fixo que não é necessariamente o centro entre os limites, penalizando desvios deste alvo. ([JMP][2])\nÍndices para distribuições não-normais: adaptações via quantis ou transformações.\nAnálise multivariada de capacidade: quando características de qualidade múltiplas devem simultaneamente atender limites, usando PCA ou índices multivariados.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#referências-para-consulta",
    "href": "C5_IndCapacity.html#referências-para-consulta",
    "title": "5  Índices de Capacidade",
    "section": "5.9 Referências para Consulta",
    "text": "5.9 Referências para Consulta\nAs referências usadas foram Montgomery (2012), Kotz e Johnson (1993), Sahay (2014), Benková et al. (2024), Grau (2007) e Team (2024).\n\n\n\n\n\n\n\n\n\n\n\nBenková, M. et al. 2024. «Process Capability Evaluation Using Capability Indices as Tools for Process Assessment: A Case Study». Mathematics 12 (11): 1679. https://doi.org/10.3390/math12111679.\n\n\nGrau, Daniel. 2007. «Generalization of Usual Capability Indices for Unilateral Tolerances». arXiv math/0702841.\n\n\nKotz, Samuel, e Norman L. Johnson. 1993. Process Capability Indices. 1.ª ed. Boca Raton, FL: CRC Press.\n\n\nMontgomery, Douglas C. 2012. Statistical Quality Control. 7.ª ed. John Wiley & Sons.\n\n\nSahay, A. 2014. «Process Capability Analysis for Six Sigma». Real Lean Six Sigma Quality 1 (1).\n\n\nTeam, PCI Development. 2024. «pci: A Collection of Process Capability Index Functions». R package documentation. https://cran.r-project.org/web/packages/pci/pci.pdf.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índices de Capacidade</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referências",
    "section": "",
    "text": "Benková, M. et al. 2024. “Process Capability Evaluation Using\nCapability Indices as Tools for Process Assessment: A Case\nStudy.” Mathematics 12 (11): 1679. https://doi.org/10.3390/math12111679.\n\n\nBotter, Denise Aparecida. 2013. “Inspeção de Qualidade.”\nNotas de Aula. https://www.ime.usp.br/~botter/mae532/Inspecao.pdf.\n\n\nCarpinetti, Luiz C. R. 2003. Controle Da Qualidade de Processo.\n2nd ed. Universidade de São Paulo.\n\n\n(ELFT), East London Foundation Trust. n.d. “Shewhart x-Bar and s\nChart Formulas and Constants.” PDF. https://www.elft.nhs.uk/sites/default/files/import-news/x-bar-s-Chart-Formula.pdf.\n\n\nExcel, SPC for. n.d. “X-Bar-s Control Charts: Part 1.”\nWebpage. https://www.spcforexcel.com/knowledge/variable-control-charts/xbar-s-control-charts-part-1/.\n\n\nGrau, Daniel. 2007. “Generalization of Usual Capability Indices\nfor Unilateral Tolerances.” arXiv math/0702841.\n\n\nKotz, Samuel, and Norman L. Johnson. 1993. Process Capability\nIndices. 1st ed. Boca Raton, FL: CRC Press.\n\n\nMontgomery, Douglas C. 2012. Statistical Quality\nControl. 7th ed. John Wiley & Sons.\n\n\nSahay, A. 2014. “Process Capability Analysis for Six\nSigma.” Real Lean Six Sigma Quality 1 (1).\n\n\nTeam, PCI Development. 2024. “Pci: A Collection of Process\nCapability Index Functions.” R package documentation. https://cran.r-project.org/web/packages/pci/pci.pdf.\n\n\nTechnology, Massachusetts Institute of. n.d. “Tables of Constants\nfor Control Charts.” Lecture Notes / PDF. https://web.mit.edu/2.810/www/files/readings/ControlChartConstantsAndFormulae.pdf.\n\n\nUFJF, Bessegato /. n.d. “Table of Control Chart Constants.”\nPDF. https://www.bessegato.com.br/UFJF/resources/table_of_control_chart_constants_old.pdf.",
    "crumbs": [
      "Referências"
    ]
  }
]