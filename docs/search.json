[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CONTROLE ESTATÍSTICO DE QUALIDADE",
    "section": "",
    "text": "Prefácio\nO Controle Estatístico de Qualidade (CEQ) consolidou-se, ao longo do último século, como um dos pilares da moderna gestão da qualidade. Desde as contribuições pioneiras de Walter A. Shewhart, que introduziu os gráficos de controle na década de 1920, até as aplicações contemporâneas em manufatura, saúde, tecnologia da informação e administração pública, o CEQ tornou-se uma ferramenta indispensável para compreender e reduzir a variabilidade dos processos.\nMais do que um conjunto de técnicas, o CEQ representa uma mudança de paradigma: a passagem de uma postura reativa — que atua apenas quando falhas são detectadas — para uma abordagem proativa e preventiva, voltada a monitorar continuamente os processos e identificar causas de variação antes que estas se traduzam em defeitos ou perdas.\nEste projeto nasce da convicção de que a difusão do CEQ deve ir além dos ambientes industriais e alcançar diferentes áreas de conhecimento e prática profissional. Para isso, combinamos o estudo dos fundamentos estatísticos com o uso de ferramentas computacionais modernas, em especial as linguagens R e Python, que tornam possível a aplicação prática em contextos reais de análise de dados.\nNosso objetivo não é apenas apresentar técnicas, mas também estimular uma visão crítica sobre sua utilização, incentivando o leitor a compreender o “porquê” por trás dos métodos. O caminho aqui proposto é duplo: rigor matemático-estatístico aliado a uma postura prática de experimentação com softwares livres, de modo que a teoria encontre aplicação imediata em exemplos concretos.\nAssim, este trabalho pretende contribuir tanto para estudantes quanto para profissionais que buscam aprofundar-se nos métodos do CEQ, oferecendo uma base sólida para a análise, o monitoramento e a melhoria contínua de processos.\n\nEste é um Quarto Book. Para saber mais sobre Quarto Book, visite quarto.org.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "C1_Introduction.html",
    "href": "C1_Introduction.html",
    "title": "1  Introdução ao Controle Estatístico de Qualidade",
    "section": "",
    "text": "1.1 Relação entre Gráficos de Controle e Testes de Hipóteses\nA busca pela qualidade acompanha a história da produção de bens e serviços. Desde os primeiros artesãos, que inspecionavam manualmente suas peças, até os sistemas modernos de manufatura avançada e serviços digitais, sempre houve a necessidade de garantir que o produto final atendesse a requisitos previamente definidos. No entanto, foi apenas no início do século XX que a estatística passou a desempenhar um papel central nesse processo.\nO Controle Estatístico de Qualidade (CEQ) surge como uma metodologia estruturada para compreender, monitorar e melhorar processos por meio de técnicas estatísticas. Seu objetivo central é distinguir a variabilidade natural — inerente a qualquer processo — das causas especiais de variação, que sinalizam problemas ou mudanças não planejadas. Essa distinção, introduzida por Walter A. Shewhart, é a base conceitual dos gráficos de controle, uma das ferramentas mais utilizadas até hoje.\nA aplicação do CEQ traz benefícios que vão além da simples detecção de falhas. Ao proporcionar uma visão clara sobre a estabilidade de um processo, ele permite:\nAo longo das décadas, o CEQ expandiu sua influência. Inicialmente aplicado em linhas de produção industriais, hoje é utilizado em áreas tão diversas quanto saúde pública, administração de serviços, engenharia de software e educação. Essa diversidade de aplicações reflete o caráter universal das ferramentas estatísticas: qualquer processo que gere dados pode ser analisado sob a ótica do controle estatístico.\nNeste projeto, exploraremos tanto os fundamentos matemáticos e estatísticos do CEQ quanto suas aplicações práticas em softwares livres. O uso de R e Python será fundamental para ilustrar, passo a passo, como implementar as técnicas e interpretar seus resultados. Assim, o leitor poderá não apenas compreender a teoria, mas também praticá-la em contextos reais, desenvolvendo autonomia para aplicar o CEQ em sua área de atuação.\nA análise do desempenho de um gráfico de controle está intimamente ligada aos princípios do teste de hipóteses, funcionando como uma ferramenta estatística que realiza uma sequência de testes para monitorar a estabilidade de um processo. Para fins de exemplo, considere que se esteja interessado na média de uma determinada caractéristica de uma variável.\nEssencialmente, a hipótese nula (\\(H_0\\)) postula que o processo está sob controle, com sua média \\(\\mu\\) igual a um valor alvo \\(\\mu_0\\). A estrutura do gráfico reflete diretamente a lógica de um teste: a região entre os Limites de Controle (LIC e LSC) corresponde à área de não rejeição de \\(H_0\\), enquanto qualquer ponto fora desses limites cai na região de rejeição. Assim, quando um ponto amostral se posiciona dentro dos limites, não há evidências para afirmar que o processo saiu do controle.\nAo utilizar essa abordagem, estamos sujeitos a dois tipos de erros estatísticos:\nA habilidade do gráfico em detectar mudanças (como um deslocamento na média para \\(\\mu = \\mu_0 + \\delta\\)) é avaliada pela Curva Característica de Operação (CO), que calcula a probabilidade do Erro Tipo II (\\(\\beta\\)) para diferentes magnitudes de mudança (\\(\\delta\\)) e tamanhos de amostra (\\(n\\)), mantendo um \\(\\alpha\\) fixo.\nApesar das semelhanças, existem diferenças importantes na aplicação de Testes de Hipóteses (TH) e Gráficos de Controle (GC):\nAs causas que levam um processo a sair do controle podem se manifestar de várias formas, mas nem todas se alinham perfeitamente ao modelo de um teste de hipóteses clássico. Por exemplo, uma causa atribuível pode resultar em: 1. Uma mudança permanente na média para um novo valor. 2. Uma mudança temporária, com a média retornando ao estado de controle. 3. Um deslocamento constante ou uma tendência de subida/descida na média.\nÉ importante notar que apenas o primeiro cenário (uma mudança para um novo patamar fixo) corresponde diretamente ao modelo usual de teste de hipóteses que se aprende na estatística básica.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução ao Controle Estatístico de Qualidade</span>"
    ]
  },
  {
    "objectID": "C1_Introduction.html#relação-entre-gráficos-de-controle-e-testes-de-hipóteses",
    "href": "C1_Introduction.html#relação-entre-gráficos-de-controle-e-testes-de-hipóteses",
    "title": "1  Introdução ao Controle Estatístico de Qualidade",
    "section": "",
    "text": "Erro Tipo I (\\(\\alpha\\)): Ocorre quando concluímos que o processo está fora de controle, mas na verdade ele continua estável. É o equivalente a um “alarme falso”.\nErro Tipo II (\\(\\beta\\)): Acontece quando concluímos que o processo está sob controle, quando na verdade ele sofreu uma alteração. Este erro é frequentemente mais custoso para a empresa, pois uma falha real no processo não é detectada.\n\n\n\n\nTH: Geralmente, verifica a validade de uma suposição sobre um parâmetro populacional em um único ponto no tempo (ex: a média da população é igual a \\(\\mu_0\\) ?).\nGC: Seu objetivo principal é monitorar e verificar a estabilidade do processo de forma contínua ao longo do tempo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução ao Controle Estatístico de Qualidade</span>"
    ]
  },
  {
    "objectID": "C1_Introduction.html#sobre-os-softwares-usados",
    "href": "C1_Introduction.html#sobre-os-softwares-usados",
    "title": "1  Introdução ao Controle Estatístico de Qualidade",
    "section": "1.2 Sobre os Softwares Usados",
    "text": "1.2 Sobre os Softwares Usados\n\n1.2.1 Linguagem de Programação R\n\n\n1.2.2 Linguagem de Programação Python",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução ao Controle Estatístico de Qualidade</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html",
    "href": "C2_PlotOfVariables.html",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "",
    "text": "2.1 Introdução\nOs gráficos de controle para variáveis são ferramentas estatísticas desenvolvidas para monitorar características da qualidade que podem ser medidas em escala contínua, como diâmetro, peso, volume, temperatura ou tempo. Diferem dos gráficos para atributos, que se baseiam em classificações qualitativas (conforme/não conforme, defeituoso/não defeituoso), ao permitir uma análise mais detalhada tanto da tendência central quanto da variabilidade do processo.\nA lógica subjacente é simples, mas poderosa: todo processo produtivo apresenta flutuações naturais, chamadas de causas comuns de variação. No entanto, alterações significativas — as chamadas causas especiais — indicam que o processo pode estar fora de controle. Os gráficos para variáveis foram construídos justamente para separar esses dois tipos de variação, permitindo identificar quando uma intervenção é necessária.\nEntre os gráficos mais utilizados destacam-se:\nEsses gráficos compartilham uma estrutura comum: uma linha central (LC) que representa o valor esperado sob controle e dois limites de controle — superior (LSC) e inferior (LIC) — que delimitam a faixa de variação natural do processo. Valores fora dessa faixa, ou padrões não aleatórios dentro dela, são interpretados como indícios de descontrole.\nO uso adequado de gráficos para variáveis depende de decisões fundamentais: o tamanho e a frequência das amostras, a definição de subgrupos racionais e a escolha entre amplitude ou desvio padrão como medida de dispersão. Tais escolhas impactam diretamente a sensibilidade do gráfico em detectar mudanças, assim como o custo de amostragem.\nPor sua capacidade de revelar simultaneamente oscilações na média e na variabilidade, os gráficos de controle para variáveis continuam sendo uma das ferramentas mais robustas e versáteis do Controle Estatístico de Qualidade, sustentando análises confiáveis em diferentes contextos produtivos e de serviços.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#introdução",
    "href": "C2_PlotOfVariables.html#introdução",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "",
    "text": "Gráficos de Médias e Amplitudes (\\(\\bar{X}\\) e \\(R\\)): adequados quando o tamanho da amostra é pequeno (tipicamente \\(n \\leq 10\\)). O gráfico \\(\\bar{X}\\) monitora a média amostral, enquanto o gráfico R acompanha a variabilidade por meio da amplitude.\nGráficos de Médias e Desvios-Padrão (\\(\\bar{X}\\) e \\(S\\)): preferidos quando o tamanho das amostras é maior (\\(n &gt; 10\\)) ou variável, por utilizarem o desvio padrão como medida mais robusta de dispersão.\nGráficos de Medidas Individuais e Amplitudes Móveis (I-MR): aplicáveis quando não há possibilidade de coletar subgrupos de tamanho maior que 1. O gráfico I acompanha as observações individuais, enquanto o MR mede a variação entre observações consecutivas.\n\n\n\n\n\n2.1.1 Constantes Estatísticas Usadas\n\n\n\n\n\n\nFigura 2.1: Constantes Estatísticas usadas no Controle Estatístico de Qualidade para Contrução de Gráficos de Controle.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#gráfico-de-controle-para-barx",
    "href": "C2_PlotOfVariables.html#gráfico-de-controle-para-barx",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.2 Gráfico de Controle para \\(\\bar{X}\\)",
    "text": "2.2 Gráfico de Controle para \\(\\bar{X}\\)\nPara a construção dos Gráfico de Controle de \\(\\bar{X}\\), suponha que a característica de interesse, \\(X\\), tem média \\(\\mu\\) e desvio padrão \\(\\sigma\\), conhecidos. Desta forma, ao retirar uma amostra \\(X_{1}, X_{2}, \\ldots, X_{n}\\) de tamanho \\(n\\), a média amostral é dada por: \\[\\bar{X} = \\dfrac{\\sum_{i=1}^{n} X_{i}}{n}\\]\nPelo Teorema Central do Limite (TCL), sabe-se que \\(\\bar{X}\\) é normalmente distribuído com média \\(\\mu\\) e variância \\(\\sigma^{2}/n\\). Usando os fundamentos de estimação intervalar, temos que o Intervalo de Confiança (IC) de \\(100(1 - \\alpha)\\)% para \\(\\mu\\) é expresso como: \\[\\bar{X} \\pm z_{\\alpha/2} \\sqrt{\\sigma^{2}/n}.\\]\nBaseado nisso, Shewhart propôs, de modo geral, que temos um estimador \\(T\\) de alguma característica de qualidade. A partir desse princípio, a estrutura de um Gráfico de Controle Shewhart é definida por três linhas principais: uma Linha Central (LC), um Limite Superior de Controle (LSC) e um Limite Inferior de Controle (LIC).\nSe considerarmos \\(T\\) como esse estimador, com média \\(\\mu_T\\) e desvio-padrão \\(\\sigma_T\\), os limites são calculados da seguinte forma:\n\\[\n\\text{Limites} = \\begin{cases} \\mu_T - L\\sigma_T, \\quad \\text{se o Limite for Inferior} \\\\ \\mu_T, \\quad \\text{se o Limite for Central} \\\\ \\mu_T + L\\sigma_T, \\quad \\text{se o Limite for Superior} \\end{cases}\n\\tag{2.1}\\]\nNessas fórmulas, \\(L\\) representa a distância dos limites de controle em relação à linha central, expressa em unidades de desvio-padrão. Os limites são determinados com base na média e no desvio-padrão da variável quando o processo está operando isento de causas atribuíveis, ou seja, quando está sob controle estatístico.\nContudo, a escolha do valor de \\(L\\) é uma tarefa fundamental, pois impacta diretamente a sensibilidade do gráfico e as taxas de erro. Existe um trade-off clássico entre os erros tipo I e tipo II:\n\nSe L é grande: Os limites de controle ficam mais afastados da média. Isso diminui a probabilidade de um Erro Tipo I (alarme falso), mas aumenta a de um Erro Tipo II (falhar em detectar um processo fora de controle).\nSe L é pequeno: Os limites ficam mais próximos da média, o que aumenta a sensibilidade a desvios. Consequentemente, a probabilidade de Erro Tipo I sobe, enquanto a de Erro Tipo II diminui.\n\nNos EUA, tornou-se prática padrão utilizar \\(L = 3\\), estabelecendo os chamados “limites de 3 sigmas”. Como mencionado no início, a base para isso vem do Teorema Central do Limite. Com \\(L = 3\\), a probabilidade de um ponto da média amostral cair fora dos limites de controle por puro acaso (Erro Tipo I) é extremamente baixa, calculada como \\(0.0026998\\). Isso significa que, em média, um sinal incorreto de que o processo está fora de controle será gerado apenas a cada 370 pontos amostrais, aproximadamente.\n\n2.2.1 Limites de Probabilidade e de Alerta\n1. Limites de Probabilidade: Uma abordagem alternativa, mais comum no Reino Unido e em partes da Europa Ocidental, é o uso de Limites de Probabilidade. Em vez de fixar \\(L\\), primeiro se especifica a probabilidade de Erro Tipo I (\\(\\alpha\\)) desejada. Por exemplo, se especificarmos um \\(\\alpha = 0,001\\), esperamos um falso alarme a cada 1000 pontos. A partir desse \\(\\alpha\\), determinam-se os valores correspondentes da distribuição normal-padrão (\\(z_{\\alpha/2}\\)) para calcular os limites.\n2. Limites de Alerta (2\\(\\sigma\\)): Para aumentar a sensibilidade do gráfico, alguns analistas sugerem o uso de dois conjuntos de limites:\n\nLimites de Ação (3\\(\\sigma\\)): São os limites de controle tradicionais (LIC e LSC). Quando um ponto cai fora deles, uma ação corretiva é necessária para encontrar a causa atribuível;\nLimites de Alerta (2\\(\\sigma\\)): São limites mais estreitos. Se um ou mais pontos se situam entre os limites de alerta e os de ação, isso serve como um aviso de que o processo pode não estar operando adequadamente, justificando uma maior atenção.\n\nO ponto positivo dessa abordagem é o aumento da sensibilidade para detectar desvios. O ponto negativo, no entanto, é que ela também aumenta o risco de alarmes falsos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#exemplos-computacionais",
    "href": "C2_PlotOfVariables.html#exemplos-computacionais",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.3 Exemplos Computacionais",
    "text": "2.3 Exemplos Computacionais\nSerá apresentados alguns exemplos computacionais de como realizar o gráfico de controle para \\(\\bar{X}\\). A maioria dos dados serão provinientes de simulação para fins didáticos.\n\nR BaseR usando ggplot2Python\n\n\n\n\nCódigo\n# Número de Amostras Selecionadas\nk &lt;- 25\n\n# Tamanho de cada Amostra\nn &lt;- 5\n\n# Simular Dados e Adicionar Ruído aos Dados\nset.seed(42)\nvec.data &lt;- rnorm(k * n, mean = 25, sd = 1.5) + rnorm(k * n, mean = 0, sd = 1.2)\n\n# Organizar a Matriz de Dados\nmatrix.data &lt;- matrix(vec.data, nrow = k, ncol = n, byrow = TRUE)\n\n# Vetor de Médias\nvec.means &lt;- apply(matrix.data, 1, mean)\n\n# Vetor de Desvios\nvec.sds &lt;- apply(matrix.data, 1, sd)\n\n# Estimar Algumas Quantidades\nx.bar &lt;- mean(vec.means)\nx.std &lt;- 1.5\n\n# Construir Limites\nLIC &lt;- x.bar - (3 / sqrt(n)) * x.std # Limite Inferior de Controle\nLC  &lt;- 25                            # Limite Central\nLSC &lt;- x.bar + (3 / sqrt(n)) * x.std # Limite Superior de Controle\n\n# Definir limites do eixo Y para garantir que tudo seja visível\nylim &lt;- c(min(vec.means, LIC) - 7, max(vec.means, LSC) + 7)\n\n# Criar o gráfico principal com pontos e linhas\nplot(x = 1:k, y = vec.means,\n     type = \"b\", # \"b\" para both (pontos e linhas)\n     xlab = \"Amostra\",\n     ylab = \"Medida\",\n     ylim = ylim,\n     pch = 19, # Tipo de ponto (círculo sólido)\n     col = \"black\",\n     font.lab = 2 # Deixa os títulos dos eixos em negrito\n)\n\n# Adicionar as linhas de controle\nabline(h = LIC, col = \"red\", lwd = 2)\nabline(h = LC, col = \"blue\", lwd = 2)\nabline(h = LSC, col = \"red\", lwd = 2)\n\n# Adicionar a legenda\nlegend(\"topright\",\n       legend = c(\n         bquote(LSC == .(round(LSC, 2))),\n         bquote(hat(mu) == .(round(LC, 2))),\n         bquote(LIC == .(round(LIC, 2)))\n       ),\n       col = c(\"red\", \"blue\", \"red\"),\n       lwd = 2,\n       bty = \"solid\" # \"n\" Remove a caixa ao redor da legenda\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nlibrary(ggplot2)\n\n# Número de Amostras Selecionadas\nk &lt;- 25\n\n# Tamanho de cada Amostra\nn &lt;- 5\n\n# Simular Dados e Adicionar Ruído aos Dados\nset.seed(42)\nvec.data &lt;- rnorm(k * n, mean = 25, sd = 1.5) + rnorm(k * n, mean = 0, sd = 1.2)\n\n# Organizar a Matriz de Dados\nmatrix.data &lt;- matrix(vec.data, nrow = k, ncol = n, byrow = T)\n\n# Vetor de Médias\nvec.means &lt;- apply(matrix.data, 1, mean)\n\n# Vetor de Desvios\nvec.sds &lt;- apply(matrix.data, 1, sd)\n\n# Estimar Algumas Quantidades\nx.bar &lt;- mean(vec.means)\nx.std &lt;- 1.5\n\n# Construir Limites\nLIC &lt;- x.bar - (3 / sqrt(n)) * x.std # Limite Inferior de Controle\nLC  &lt;- 25                         # Limite Central\nLSC &lt;- x.bar + (3 / sqrt(n)) * x.std # Limite Superior de Controle\n\n# Construir Gráfico de Controle no ggplot2\nggplot(data = NULL, aes(x = 1:k, y = vec.means)) +\n  geom_point(size = 2) + geom_line() +\n  geom_hline(aes(yintercept = LIC, color = \"LIC\")) +\n  geom_hline(aes(yintercept = LC, color = \"LC\")) +\n  geom_hline(aes(yintercept = LSC, color = \"LSC\")) +\n  scale_color_manual(\n    values = c(\"LIC\" = \"red\", \"LC\" = \"blue\", \"LSC\" = \"red\"),\n    labels = c(\n      bquote(LIC == .(round(LIC, 2))),\n      bquote(mu[0] == .(round(x.bar, 2))),\n      bquote(LSC == .(round(LSC, 2)))\n    )\n  ) +\n  labs(\n    x = \"Amostra\",\n    y = \"Medida\",\n    color = \"Limites\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(\n    axis.title.x = element_text(face = \"bold\"),\n    axis.title.y = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Parâmetros\nk = 25  # Número de Amostras\nn = 5   # Tamanho de cada Amostra\n\n# Simular dados com semente de aleatoriedade para reprodutibilidade\nnp.random.seed(42)\nvec_data = np.random.normal(loc=25, scale=1.5, size=k*n) + np.random.normal(loc=0, scale=1.2, size=k*n)\n\n# Organizar a matriz de dados\nmatrix_data = vec_data.reshape(k, n)\n\n# Vetor de médias (média de cada linha)\nvec_means = matrix_data.mean(axis=1)\n\n# Vetor de desvios (desvio padrão amostral de cada linha, ddof=1)\nvec_sds = matrix_data.std(axis=1, ddof=1)\n\n# Estimar quantidades\nx_bar = vec_means.mean()\nx_std = 1.5\n\n# Construir limites\nlic = x_bar - (3 / np.sqrt(n)) * x_std  # Limite Inferior de Controle\nlc  = 25                               # Limite Central\nlsc = x_bar + (3 / np.sqrt(n)) * x_std  # Limite Superior de Controle\n\n# Configurar o estilo do gráfico\nsns.set_theme(style=\"ticks\") # Similar ao theme_classic()\n\n# Configurações de Figura\nfig, ax = plt.subplots(figsize=(5, 3), dpi=800)\n\nsns.lineplot(x=range(1, k+1), y=vec_means, marker=\"o\", color=\"black\", ax=ax)\n\n# Plotar as linhas de controle\nax.axhline(y=lsc, color=\"red\", linestyle=\"-\", label=f\"LSC = {lsc:.2f}\")\nax.axhline(y=lc, color=\"blue\", linestyle=\"-\", label=f\"$\\\\hat{{\\\\mu}}$ = {lc:.2f}\") # Usando LaTeX para mu\nax.axhline(y=lic, color=\"red\", linestyle=\"-\", label=f\"LIC = {lic:.2f}\")\n\n# Configurações de eixos e títulos\nax.set_ylim(18, 32)\n\n\n(18.0, 32.0)\n\n\nCódigo\nax.set_xlabel(\"Amostra\", weight=\"bold\", fontsize=12)\nax.set_ylabel(\"Medida\", weight=\"bold\", fontsize=12)\n\n# Configurações de Legenda\nax.legend(prop={\"size\":8, \"weight\": \"bold\"}, loc=\"upper right\", frameon=False) # bbox_to_anchor=(1, 0.5), \n\n# Outras configurações\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Exibição da Figura\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#demais-variações-do-gráfico-de-controle-de-barx",
    "href": "C2_PlotOfVariables.html#demais-variações-do-gráfico-de-controle-de-barx",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.4 Demais Variações do Gráfico de Controle de \\(\\bar{X}\\)",
    "text": "2.4 Demais Variações do Gráfico de Controle de \\(\\bar{X}\\)\n\n2.4.1 Gráficos de Médias e Amplitudes (\\(\\bar{X}\\) e \\(R\\))\nNa prática da construção de gráficos de controle, a média (\\(\\mu\\)) e o desvio-padrão (\\(\\sigma\\)) do processo raramente são conhecidos. Portanto, esses parâmetros precisam ser estimados a partir de dados amostrais. A premissa fundamental é que essas amostras, ou subgrupos, sejam coletadas em um momento em que o processo esteja operando sob controle estatístico.\nPara isso, Walter Shewhart sugeriu um método prático: a coleta de \\(m\\) subgrupos (geralmente entre 20 a 25) de tamanho \\(n\\) relativamente pequeno (4, 5 ou 6 itens cada). Essa abordagem visa a construção de “subgrupos racionais” com um baixo custo de amostragem.\nPara estimar a média global do processo, \\(\\mu\\), utilizamos a média das médias de todos os subgrupos. Sejam \\(\\bar{X}_1, \\bar{X}_2, \\ldots, \\bar{X}_m\\) as médias de cada um dos \\(m\\) subgrupos. O melhor estimador para \\(\\mu\\) é a grande média, denotada por \\(\\bar{\\bar{X}}\\): \\[\\bar{\\bar{X}} = \\frac{\\sum_{i=1}^{m} \\bar{X}_i}{m}.\\]\nOnde \\(\\bar{X}_i\\) é a média amostral do i-ésimo subgrupo. Por essa razão, o valor de \\(\\bar{\\bar{x}}\\) será usado como a linha central (LC) do gráfico \\(\\bar{X}\\).\nPara construir os limites de controle, tanto do gráfico \\(\\bar{X}\\) quanto do gráfico \\(R\\) (será visto mais a frente), precisamos de um estimador para o desvio-padrão do processo, \\(\\sigma\\). Essa estimativa pode ser obtida a partir dos desvios-padrões de cada subgrupo ou, mais comumente, a partir das amplitudes das amostras. Para esta análise, optaremos pelo método das amplitudes.\nA amplitude (\\(R\\)) de uma amostra é a diferença entre o valor máximo e o valor mínimo observados nela: \\[R = X_{\\text{max}} - X_{\\text{min}}.\\]\nSendo \\(R_1, R_2, \\ldots, R_m\\) as amplitudes de cada um dos \\(m\\) subgrupos, calculamos a amplitude média (\\(\\bar{R}\\)) como: \\[\\bar{R} = \\frac{\\sum_{i=1}^{m} R_i}{m}.\\]\nCom as estimativas da média (\\(\\bar{\\bar{x}}\\)) e da variabilidade (via \\(\\bar{R}\\)) do processo, podemos construir os limites de controle para o gráfico \\(\\bar{X}\\), que monitora a tendência central do processo.\n\\[\n\\text{Limites} = \\begin{cases} \\bar{\\bar{X}} + A_2 \\bar{R}, \\quad \\text{se o Limite for Inferior} \\\\ \\bar{\\bar{X}}, \\quad \\text{se o Limite for Central} \\\\ \\bar{\\bar{X}} - A_2 \\bar{R}, \\quad \\text{se o Limite for Superior} \\end{cases}.\n\\tag{2.2}\\]\nAs constantes \\(A_2\\) são tabeladas e dependem do tamanho do subgrupo (\\(n\\)). Elas podem ser encontradas em apêndices de livros de referência sobre o tema, como o “Introdução ao Controle de Qualidade” de Montgomery. Tal constantes e outras podem ser vistas na Figura 2.1.\n\n2.4.1.1 Exemplos Computacionais\nPara exemplificar o gráfico de controle recém apresentado, será usado o Exemplo 6.1. página 239 (Montgomery, 2009): Medições da Largura de Fluxo (mícrons) para o Processo de Cozimento Duro.\n\nR BaseR usando ggplot2Python\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Vetor de Médias\nvec.means &lt;- apply(samples.x, 1, mean)\n\n# Vetor de Amplitudes\nvec.range &lt;- apply(samples.x, 1, function(x) max(x) - min(x))\n\n# Estimar Algumas Quantidades\nx.bar &lt;- mean(vec.means)\nx.range &lt;- mean(vec.range)\n\n# Definir Constantes Estatíticas\nA2 &lt;- 0.729\n\n# Construir Limites\nLIC &lt;- x.bar - A2 * x.range # Limite Inferior de Controle\nLC  &lt;- x.bar                # Limite Central\nLSC &lt;- x.bar + A2 * x.range # Limite Inferior de Controle\n\n# Definir limites do eixo Y para garantir que tudo seja visível\nylim &lt;- c(min(vec.means, LIC) - 0.25, max(vec.means, LSC) + 0.25)\n\n# Criar o gráfico principal com pontos e linhas\nplot(x = 1:k, y = vec.means,\n     type = \"b\", # \"b\" para both (pontos e linhas)\n     xlab = \"Amostra\",\n     ylab = \"Medida\",\n     ylim = ylim,\n     pch = 19, # Tipo de ponto (círculo sólido)\n     col = \"black\",\n     font.lab = 2 # Deixa os títulos dos eixos em negrito\n)\n\n# Adicionar as linhas de controle\nabline(h = LIC, col = \"red\", lwd = 2)\nabline(h = LC, col = \"blue\", lwd = 2)\nabline(h = LSC, col = \"red\", lwd = 2)\n\n# Adicionar a legenda\nlegend(\"topright\",\n       legend = c(\n         bquote(LSC == .(round(LSC, 2))),\n         bquote(hat(mu) == .(round(LC, 2))),\n         bquote(LIC == .(round(LIC, 2)))\n       ),\n       col = c(\"red\", \"blue\", \"red\"),\n       lwd = 2,\n       cex = 0.75,\n       bty = \"solid\" # \"n\" Remove a caixa ao redor da legenda\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# Criando a Tabela 6.1 em R\ntbl.6.1 &lt;- matrix(\n  c(\n    1, 1.3235, 1.4128, 1.6744, 1.4573,\n    2, 1.4314, 1.3592, 1.6075, 1.4666,\n    3, 1.4284, 1.4871, 1.4932, 1.4324,\n    4, 1.5028, 1.6352, 1.3841, 1.2831,\n    5, 1.5604, 1.2735, 1.5265, 1.4362,\n    6, 1.5955, 1.5451, 1.3574, 1.3281,\n    7, 1.6274, 1.5064, 1.8366, 1.4177,\n    8, 1.4190, 1.4303, 1.6637, 1.6067,\n    9, 1.3884, 1.7277, 1.5355, 1.5176,\n    10, 1.4039, 1.6697, 1.5089, 1.6477,\n    11, 1.4158, 1.7667, 1.4278, 1.5927,\n    12, 1.5821, 1.3355, 1.5777, 1.3908,\n    13, 1.2856, 1.4106, 1.4447, 1.6388,\n    14, 1.4951, 1.4036, 1.5893, 1.6458,\n    15, 1.3589, 1.2863, 1.5996, 1.2497,\n    16, 1.5747, 1.5301, 1.5171, 1.1839,\n    17, 1.3680, 1.7269, 1.3957, 1.5019,\n    18, 1.4163, 1.3864, 1.3057, 1.6210,\n    19, 1.5796, 1.4185, 1.6541, 1.5116,\n    20, 1.7106, 1.4412, 1.2361, 1.3824,\n    21, 1.4371, 1.5051, 1.3485, 1.5670,\n    22, 1.4738, 1.5936, 1.6583, 1.4973,\n    23, 1.5917, 1.4333, 1.5551, 1.5295,\n    24, 1.6399, 1.5243, 1.5705, 1.5563,\n    25, 1.5797, 1.3663, 1.6240, 1.3732\n  ),\n  ncol = 5, byrow = TRUE\n)\n\n# Alguns ajustes\ntbl.6.1 &lt;- as.data.frame(tbl.6.1)\ncolnames(tbl.6.1) &lt;- c(\"Amostra\", \"x1\", \"x2\", \"x3\", \"x4\")\n\n# Obter apenas as amostras\nsamples.x &lt;- tbl.6.1[, -1]\n\n# Vetor de Médias\nvec.means &lt;- apply(samples.x, 1, mean)\n\n# Vetor de Amplitudes\nvec.range &lt;- apply(samples.x, 1, function(x) max(x) - min(x))\n\n# Estimar Algumas Quantidades\nx.bar &lt;- mean(vec.means)\nx.range &lt;- mean(vec.range)\n\n# Definir Constantes Estatíticas\nA2 &lt;- 0.729\n\n# Construir Limites\nLIC &lt;- x.bar - A2 * x.range # Limite Inferior de Controle\nLC  &lt;- x.bar                # Limite Central\nLSC &lt;- x.bar + A2 * x.range # Limite Inferior de Controle\n\nlibrary(ggplot2)\n\n# Construir Gráfico de Controle no ggplot2\nggplot(data = NULL, aes(x = 1:nrow(samples.x), y = vec.means)) +\n  geom_point(size = 2) + geom_line() +\n  geom_hline(aes(yintercept = LIC, color = \"LIC\")) +\n  geom_hline(aes(yintercept = LC, color = \"LC\")) +\n  geom_hline(aes(yintercept = LSC, color = \"LSC\")) +\n  scale_color_manual(\n    values = c(\"LIC\" = \"red\", \"LC\" = \"blue\", \"LSC\" = \"red\"),\n    labels = c(\n      bquote(LIC == .(round(LIC, 2))),\n      bquote(mu[0] == .(round(x.bar, 2))),\n      bquote(LSC == .(round(LSC, 2)))\n    )\n  ) +\n  labs(\n    x = \"Amostra\",\n    y = \"Medida\",\n    color = \"Limites\"\n  ) +\n  theme_classic(base_size = 12) +\n  theme(\n    axis.title.x = element_text(face = \"bold\"),\n    axis.title.y = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ntbl61 = np.array([\n    [1, 1.3235, 1.4128, 1.6744, 1.4573],\n    [2, 1.4314, 1.3592, 1.6075, 1.4666],\n    [3, 1.4284, 1.4871, 1.4932, 1.4324],\n    [4, 1.5028, 1.6352, 1.3841, 1.2831],\n    [5, 1.5604, 1.2735, 1.5265, 1.4362],\n    [6, 1.5955, 1.5451, 1.3574, 1.3281],\n    [7, 1.6274, 1.5064, 1.8366, 1.4177],\n    [8, 1.4190, 1.4303, 1.6637, 1.6067],\n    [9, 1.3884, 1.7277, 1.5355, 1.5176],\n    [10, 1.4039, 1.6697, 1.5089, 1.6477],\n    [11, 1.4158, 1.7667, 1.4278, 1.5927],\n    [12, 1.5821, 1.3355, 1.5777, 1.3908],\n    [13, 1.2856, 1.4106, 1.4447, 1.6388],\n    [14, 1.4951, 1.4036, 1.5893, 1.6458],\n    [15, 1.3589, 1.2863, 1.5996, 1.2497],\n    [16, 1.5747, 1.5301, 1.5171, 1.1839],\n    [17, 1.3680, 1.7269, 1.3957, 1.5019],\n    [18, 1.4163, 1.3864, 1.3057, 1.6210],\n    [19, 1.5796, 1.4185, 1.6541, 1.5116],\n    [20, 1.7106, 1.4412, 1.2361, 1.3824],\n    [21, 1.4371, 1.5051, 1.3485, 1.5670],\n    [22, 1.4738, 1.5936, 1.6583, 1.4973],\n    [23, 1.5917, 1.4333, 1.5551, 1.5295],\n    [24, 1.6399, 1.5243, 1.5705, 1.5563],\n    [25, 1.5797, 1.3663, 1.6240, 1.3732]\n])\n\n# Obter apenas as amostras\nsamples_x = tbl61[:, 1:]\n\n# Vetor de médias (média de cada linha)\nvec_means = samples_x.mean(axis=1)\n\n# Vetor de desvios (desvio padrão amostral de cada linha, ddof=1)\nvec_range = samples_x.ptp(axis=1)\n\n# Estimar quantidades\nx_bar = vec_means.mean()\nx_range = vec_range.mean()\n\n# Definir Constantes Estatíticas\nA2 = 0.729\n\n# Construir limites\nlic = x_bar - A2 * x_range  # Limite Inferior de Controle\nlc  = x_bar                 # Limite Central\nlsc = x_bar + A2 * x_range  # Limite Inferior de Controle\n\n# Configurar o estilo do gráfico\nsns.set_theme(style=\"ticks\") # Similar ao theme_classic()\n\n# Configurações de Figura\nfig, ax = plt.subplots(figsize=(5, 3), dpi=800)\n\nsns.lineplot(x=range(1, samples_x.shape[0]+1), y=vec_means, marker=\"o\", color=\"black\", ax=ax)\n\n# Plotar as linhas de controle\nax.axhline(y=lsc, color=\"red\", linestyle=\"-\", label=f\"LSC = {lsc:.2f}\")\nax.axhline(y=lc, color=\"blue\", linestyle=\"-\", label=f\"$\\\\hat{{\\\\mu}}$ = {lc:.2f}\") # Usando LaTeX para mu\nax.axhline(y=lic, color=\"red\", linestyle=\"-\", label=f\"LIC = {lic:.2f}\")\n\n# Configurações de eixos e títulos\nax.set_ylim(min(vec_means.min(), lic) - 0.25, max(vec_means.max(), lsc) + 0.25)\n\n\n(1.0361290280000002, 1.9497169720000003)\n\n\nCódigo\nax.set_xlabel(\"Amostra\", weight=\"bold\", fontsize=12)\nax.set_ylabel(\"Medida\", weight=\"bold\", fontsize=12)\n\n# Configurações de Legenda\nax.legend(prop={\"size\":8, \"weight\": \"bold\"}, loc=\"upper right\", frameon=False) # bbox_to_anchor=(1, 0.5), \n\n# Outras configurações\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Exibição da Figura\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.2 Gráficos de Médias e Desvio Padrão (\\(\\bar{X}\\) e \\(S\\))\n\n2.4.2.1 Exemplos Computacionais\n\nR BaseR usando ggplot2Python",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#gráfico-de-controle-para-r",
    "href": "C2_PlotOfVariables.html#gráfico-de-controle-para-r",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.5 Gráfico de Controle para \\(R\\)",
    "text": "2.5 Gráfico de Controle para \\(R\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C2_PlotOfVariables.html#gráfico-de-controle-para-s",
    "href": "C2_PlotOfVariables.html#gráfico-de-controle-para-s",
    "title": "2  Gráficos de Controle para Variáveis",
    "section": "2.6 Gráfico de Controle para \\(S\\)",
    "text": "2.6 Gráfico de Controle para \\(S\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Gráficos de Controle para Variáveis</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html",
    "href": "C3_CCO_CMS.html",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "",
    "text": "3.1 Introdução\nEspecificar o plano amostral, a frequência de coleta e os limites de controle de um processo são algumas das decisões críticas na construção de gráficos de controle. Na inviabilidade de inspecionar todos os itens produzidos, são selecionados uma certa quantidade por lote de forma aleatória para composição das amostras. Naturalmente, quanto mais itens amostrados, maior a aproximação da representação real do processo e consequente maior controle. Logo, as alternativas viáveis são, ou tomar amostras pequenas com maior frequência, ou amostras grandes com menor frequência (Carpinetti 2003; Montgomery 2012).\nA depender do número defeitos presentes, o lote pode ser aceito ou rejeitado, parelho ao teste de hipóteses:\n\\[\n\\left\\{ \\begin{array} HH_0: p = p_0\\\\ H_1: p \\neq p_0 \\end{array} \\right.\n\\]\nonde \\(p\\) representa a proporção de defeitos na produção (Botter 2013).\nQuando estabelecemos limites de controle afastados da linha central, aumentamos a tolerância do processo, diminuindo assim o risco de ocorrer pontos fora dos limites. Esse risco é denominado erro tipo I (\\(\\alpha\\)) ou risco do produtor, responsável por indicar condições fora do controle sem causa atribuível (alarme falso).\nA presença de baixos valores para o erro tipo I dificulta a detecção de defeitos reais, implicando no aumento de itens dentro dos limites de controle, quando o processo na realidade estiver fora de controle. A esse risco denominamos erro do tipo II (\\(\\beta\\)) ou risco do consumidor.\nNo caso de aproximação dos limites de controle da linha central gera o efeito contrário; quando o risco do produtor aumenta, o do consumidor diminui (Montgomery 2012; Botter 2013). O cenário desejável é a identificação eficiente desses defeitos antes que ele seja repassado ao consumidor, garantindo a qualidade do produto.\nPara um processo controlado sob condição de normalidade – \\(X_{i} \\sim N(\\mu, \\sigma^2)\\) – em um nível de operação (\\(L\\)) temos que a probabilidade do processo estar sob controle é dada por\n\\[\nP\\left[LIC \\leq \\bar{X}_i \\leq LSC \\right] \\Rightarrow P\\left[\\dfrac{\\mu -L\\sigma}{\\sqrt{n}} \\leq \\bar{X}_i \\leq \\dfrac{\\mu + L\\sigma}{\\sqrt{n}}\\right],\n\\] onde \\(LIC\\) representa o limite inferior de controle e \\(LSC\\), o limite superior de controle, \\(\\sigma\\) o desvio-padrão da operação e \\(n\\), o número de amostras.\nPara um processo operado em \\(3\\sigma\\) (\\(L=3\\)), temos que \\[\\therefore P\\left[ \\dfrac{\\mu -3\\sigma}{\\sqrt{n}} \\leq \\bar{X}_i \\leq \\dfrac{\\mu + 3\\sigma}{\\sqrt{n}}\\right] = 0.9973.\\]\nPela normalização dos dados – \\(X_{i} \\sim N(0, 1)\\)–, o erro tipo II corresponde a 99,73% e o erro tipo I a 0,27%. Em outras palavras, o processo acusará 27 alarmes falsos em 10.000 itens produzidos.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html#curva-característica-da-operação-cco",
    "href": "C3_CCO_CMS.html#curva-característica-da-operação-cco",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "3.2 Curva Característica da Operação (CCO)",
    "text": "3.2 Curva Característica da Operação (CCO)\nA capacidade dos gráficos \\(\\bar{X}\\) e \\(R\\) de detectar mudanças no processo é descrita pelas chamadas Curvas Características de Operação (CCO), utilizadas na fase II de monitoramento de um processo. Considerando que a variabilidade do processo se mantém constante ao longo do tempo, \\(\\beta\\), nesse caso, representa a probabilidade de não serem detectadas mudanças na média na amostra subsequente (Montgomery 2012).\nEm termos probabilísticos, o risco do consumidor (\\(\\beta\\)) para uma dada média em um nível \\(\\mu_0\\) mudar para \\(\\mu_1\\), sendo \\(\\mu_1 = \\mu_0 + k\\sigma\\), pode descrito ser como\n\\[\n\\beta = P \\left[ LIC \\leq \\bar{X} \\leq LSC | \\mu = \\mu_1 = \\mu_0 + k\\sigma \\right],\n\\]\nonde \\(k\\) representa o número de desvios (\\(\\sigma\\)) em relação à média (\\(\\mu_0\\)).\nLevando em conta a média amostral com distribuição normal \\(\\bar{x} \\sim N(\\mu, \\sigma^2/n)\\) e limites superior e inferior de controle \\(LSE = \\mu_0 + L\\sigma/\\sqrt{n}\\) e \\(LIE = \\mu_0 - L\\sigma/\\sqrt{n}\\), os termos podem ser trabalhados em termos de função de distribuição cumulativa normal \\(\\Phi(\\cdot)\\). Desta forma, a função \\(\\beta\\) pode ser expressa como\n\\[ \\beta = \\Phi \\left[\\dfrac{LSE - \\mu_1}{\\sigma \\sqrt{n}}\\right] - \\Phi \\left[\\dfrac{LIE + \\mu_1}{\\sigma \\sqrt{n}}\\right].\n\\]\nA partir das definições, podemos realizar as substituições dos limites de controle amostrais e da nova média \\(\\mu_1\\), resultando em\n\\[\n\\beta = \\Phi \\left[\\dfrac{(\\mu_0 + L\\sigma/\\sqrt{n}) - (\\mu_0 + k\\sigma)}{\\sigma \\sqrt{n}}\\right] - \\Phi \\left[\\dfrac{(\\mu_0 - L\\sigma/\\sqrt{n}) + (\\mu_0 + k\\sigma)}{\\sigma \\sqrt{n}}\\right].\n\\]\nFazendo os devidos ajustes de cálculo, a equação acima pode ser simplificada para\n\\[\n\\beta = \\Phi \\left[L - k\\sqrt{n}\\right] - \\Phi \\left[-L - k\\sqrt{n}\\right].\n\\]\nPara ilustrar sua aplicação, tomemos um processo que opera em \\(3\\sigma\\), coletando cinco amostras por inspeção (\\(n=5\\)). Para determinar a probabilidade de deteção de mudança na média em dois desvios-padrão (\\(k=2\\)) na primeira amostra após o deslocamento para \\(\\mu_1 = \\mu_0 + 2\\sigma\\), incialmente calculamos a probaibilidade de não-detecção (\\(\\beta\\)):\n\nRPython\n\n\n\nCódigo\nL = 3 ; k = 2\nbeta = pnorm(L - k*sqrt(5)) - pnorm(-L - k*sqrt(5))\nround(beta, 4)\n\n[1] 0.0705\n\n\n\n\nCódigo\nimport numpy as np\nfrom scipy.stats import norm\nL = 3 ; k = 2\nbeta = norm.cdf(L - k*np.sqrt(5)) - norm.cdf(-L - k*np.sqrt(5))\nprint(round(beta, 4))\n\n\n0.0705\n\n\n\n\n\nLogo, a probabilidade de decteção do deslocamento é \\(1-\\beta = 1 - 0,0705 = 0,9295\\) ou 92,95%. De forma progressiva, podemos construir as CCOs para gráfico de médias (\\(\\bar{X}\\)) para diferentes números de amostra. A definição dos pontos da curva depende do cruzamento entre o valor do risco \\(\\beta\\) em relação a extensão do deslocamento (\\(k\\)) para um número de amostras (\\(n\\)).\n\nRPython\n\n\n\nCódigo\nL = 3                             # Nível do processo \nk = seq(0, 5, length.out = 100)   # Valores para deslocamento\n\n# Probabilidade de detecção de mudanças (erro tipo II)\nbeta_1 = pnorm(L - k*sqrt(1)) - pnorm(-L - k*sqrt(1))     # para n = 1\nbeta_2 = pnorm(L - k*sqrt(2)) - pnorm(-L - k*sqrt(2))     # para n = 2\nbeta_5 = pnorm(L - k*sqrt(5)) - pnorm(-L - k*sqrt(5))     # para n = 5\nbeta_10 = pnorm(L - k*sqrt(10)) - pnorm(-L - k*sqrt(10))  # para n = 10\nbeta_20 = pnorm(L - k*sqrt(20)) - pnorm(-L - k*sqrt(20))  # para n = 20\n\n# Gráfico comparativo das Curvas\n#par(mfrow = c(1, 1))\nplot(k, beta_1, type = \"l\", lwd = 1.25, lty=2, \n     col = \"black\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, beta_2, type = \"l\", lwd = 1.25, lty=2, \n     col = \"red\", axes=F, xlab=\"\",ylab=\"\")\npoints(1,pnorm(L - 1*sqrt(2)) - pnorm(-L - 1*sqrt(2)), col = \"red\", pch = 19, cex = 1.25) \npar (new = TRUE)\nplot(k, beta_5, type = \"l\", lwd = 1.25, lty=2, \n     col = \"green\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, beta_10, type = \"l\", lwd = 1.25, lty=2, \n     col = \"blue\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, beta_20, type = \"l\", lwd = 1.25, lty=2, \n     col = \"purple\", axes=T,\n     xlab = \"Deslocamento da Média (k)\",\n     ylab = \"Risco do Consumidor (β)\",\n     main = \"Curva Característica de Operação -- Gráfico X-bar\",\n     ylim = c(0,1))\npoints(1,pnorm(L - 1*sqrt(20)) - pnorm(-L - 1*sqrt(20)), col = \"red\", pch = 19, cex = 1.25) \ngrid()\nlegend(\"topright\", title=\"Amostras\", lwd = 1.25, lty = 2,\n     legend = c(\"n = 1\", \"n = 2\", \"n = 5\", \"n = 10\", \"n = 20\"),  \n     col = c(\"black\", \"red\", \"green\", \"blue\", \"purple\"))\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\nL = 3                       # Nível do processo \nk = np.linspace(0, 5, 100)  # Valores para deslocamento\n\n# Probabilidade de detecção de mudanças (erro tipo II)\nbeta_1 = norm.cdf(L - k*np.sqrt(1)) - norm.cdf(-L - k*np.sqrt(1))    # para n = 1\nbeta_2 = norm.cdf(L - k*np.sqrt(2)) - norm.cdf(-L - k*np.sqrt(2))    # para n = 2\nbeta_5 = norm.cdf(L - k*np.sqrt(5)) - norm.cdf(-L - k*np.sqrt(5))    # para n = 5\nbeta_10 = norm.cdf(L - k*np.sqrt(10)) - norm.cdf(-L - k*np.sqrt(10)) # para n = 10\nbeta_20 = norm.cdf(L - k*np.sqrt(20)) - norm.cdf(-L - k*np.sqrt(20)) # para n = 20\n\n# Gráfico comparativo das Curvas\nplt.plot(k, beta_1, linestyle = '--', linewidth = .75, color = \"black\", label = 'n = 1')\nplt.plot(k, beta_2, linestyle = '--', linewidth = .75, color = \"red\", label = 'n = 2')\nplt.plot(1, norm.cdf(L - 1*np.sqrt(2)) - norm.cdf(-L - 1*np.sqrt(2)), 'ro')\nplt.plot(k, beta_5, linestyle = '--', linewidth = .75, color = \"green\", label = 'n = 5')\nplt.plot(k, beta_10, linestyle = '--', linewidth = .75, color = \"blue\", label = 'n = 10')\nplt.plot(k, beta_20, linestyle = '--', linewidth = .75, color = \"purple\", label = 'n = 20')\nplt.plot(1, norm.cdf(L - 1*np.sqrt(20)) - norm.cdf(-L - 1*np.sqrt(20)), 'ro')\nplt.xlabel('Deslocamento da Média (k)')\nplt.ylabel('Risco do Consumidor (β)')\nplt.title('Curva Característica de Operação -- Gráfico X-bar')\nplt.ylim(0,1)\n\n\n(0.0, 1.0)\n\n\nCódigo\nplt.legend(title='Amostras', fontsize=9)\nplt.grid(True, alpha=.3)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nÉ notável que um número pequeno de amostras implica em um baixo poder de detecção. Por exemplo, em um caso de inspeção com duas amostras (\\(n=2\\), destacado no gráfico no ponto vermelho mais acima), a probabilidade de identificação de uma mudança em um desvio-padrão (\\(k=1\\)) na amostra subsequente é de apenas 5,64% (\\(\\beta=0.9436 \\therefore 1-\\beta=0.0564\\)). Já com \\(n=20\\) (ponto vermelho mais abaixo), a detecção efetiva nas mesmas condições é de 92,95% na primeira amostra após a mudança na média (\\(\\beta=0.0705 \\therefore 1-\\beta=0.9295\\)). Isso demonstra o comportamento natural de melhoria na detecção de defeitos conforme o número de amostras é ampliado.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html#compimento-médio-da-sequência-cms",
    "href": "C3_CCO_CMS.html#compimento-médio-da-sequência-cms",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "3.3 Compimento Médio da Sequência (CMS)",
    "text": "3.3 Compimento Médio da Sequência (CMS)\nOutra análise possível é a definição da probabilidade de identificar o deslocamento a cada nova amostra. Utilizando o exemplo já mencionado (\\(L=3\\), \\(n=2\\), \\(k=1\\) e \\(\\beta = 0.9436\\)), a detecção de mudanças na segunda amostra é dado por \\(\\beta(1-\\beta)\\), isto é, a oscilação não foi apontada na primeira amostra (risco \\(\\beta\\)), ocorrendo na segunda amostra (\\(1-\\beta\\)). Desta forma, \\(0.9436^1(1-0.9436) = 0.0532\\), resultando em uma probabilidade de 5,32%. Na terceira, a probabilidade é dada por \\(\\beta^2(1-\\beta)\\), isto é, \\(0.9436^2(1-0.9436) = 0.0502\\) ou 5,02%. Seguindo progressivamente a mesma lógica, a probabilidade de captar a oscilação da média na \\(r\\)-ésima amostra pode ser generalizada por\n\\[\n\\beta^{r-1}(1-\\beta).\n\\]\nBuscando conhecer número médio de amostras coletadas até que um sinal seja emitido pelo gráfico de controle \\(\\bar{X}\\), podemos descrever o quantitativo por meio de um somatório de \\(\\beta\\), de tal forma que\n\\[\n\\sum_{i=1}^\\infty \\beta^{r=1}(1-\\beta) = \\dfrac{1}{1-\\beta} = ARL.\n\\]\nEssa medida é denominada Comprimento Médio de Sequência (ARL1), sendo utilizada para subsidiar decisões relativas ao tamanho da amostra e à frequência de amostragem. Na prática, indica quantos pontos de um processo consegue registrar antes que o gráfico aponte uma possível alteração ou desvio, seja ele dentro de controle (\\(ARL_0\\)) ou fora de controle (\\(ARL_1\\)).\nTomando como cenário um processo em \\(3\\sigma\\) sob controle, o risco de pontos fora de controle (erro tipo I) é de \\(0.0027\\). Logo, podemos calcular\n\nCódigo\nARL_0 =  1 / 0.0027\nround(ARL_0, 2)\n\n[1] 370.37\nsignificando dizer que o processo acusará um alarme falso, em média, a cada 370 amostras. Em um caso alternativo, onde um processo com \\(n=5\\) amostras coletadas tenha sofrido alguma alteração em sua média, o \\(ARL_1\\) é dado por \\[\nARL_1 = \\dfrac{1}{1-\\beta} = \\dfrac{1}{1 - \\left\\{ \\Phi \\left[L - k\\sqrt{n}\\right] - \\Phi \\left[-L - k\\sqrt{n}\\right] \\right\\}}.\n\\]\n\nRPython\n\n\n\n\nCódigo\narl_1 =  1 / (1 - pnorm(3 - 1*sqrt(5)) - pnorm(-3 - 1*sqrt(5)))\nround(arl_1, 2)\n\n\n[1] 4.5\n\n\n\n\n\n\nCódigo\narl_1 =  1 / (1 - norm.cdf(3 - 1*np.sqrt(5)) - norm.cdf(-3 - 1*np.sqrt(5)))\nprint(round(arl_1, 2))\n\n\n4.5\n\n\n\n\n\nPortanto, são necessárias aproximadamente cinco amostras coletadas para detecção de uma mudança de \\(1\\sigma\\) (\\(k=1\\)).\nPara a construção do gráfico de ARL considerando diferentes tamanhos de amostra (\\(n\\)) e de deslocamentos da média (\\(k\\)), temos que considerar o caso de ocorrência de pontos fora de controle (\\(ARL_1\\)).\n\nRPython\n\n\n\n\nCódigo\nL = 3                             # Nível do processo \nk = seq(0, 5, length.out = 100)   # Valores para deslocamento\n\n# Comprimento Médio de Sequência\nARL1 =  1 / (1 - (pnorm(L - k*sqrt(1)) - pnorm(-L - k*sqrt(1))))\nARL2 =  1 / (1 - (pnorm(L - k*sqrt(2)) - pnorm(-L - k*sqrt(2))))\nARL5 =  1 / (1 - (pnorm(L - k*sqrt(5)) - pnorm(-L - k*sqrt(5))))\nARL10 =  1 / (1 - (pnorm(L - k*sqrt(10)) - pnorm(-L - k*sqrt(10))))\nARL20 =  1 / (1 - (pnorm(L - k*sqrt(20)) - pnorm(-L - k*sqrt(20))))\n\n# Gráfico comparativo das Curvas\npar(mfrow = c(1, 1))\nplot(k, ARL1, type = \"l\", lwd = 1.25, lty=1, col = \"black\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, ARL2, type = \"l\", lwd = 1.25, lty=1, col = \"red\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, ARL5, type = \"l\", lwd = 1.25, lty=1, col = \"green\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, ARL10, type = \"l\", lwd = 1.25, lty=1, col = \"blue\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(k, ARL20, type = \"l\", lwd = 1.25, lty=1, col = \"purple\", axes=T,\n    xlab = \"Deslocamento da Média (k)\",\n    ylab = \"Comprimento Médio de Sequência (ARL)\",\n    main = \"Comprimento Médio de Sequência vs. Deslocamento da Média\",\n    ylim=c(0,400))\naxis(1)\naxis(2)\ngrid()\nlegend(\"topright\", title=\"Amostras\", lwd = 1.25, lty = 1,\n     legend = c(\"n = 1\", \"n = 2\", \"n = 5\", \"n = 10\", \"n = 20\"),  \n     col = c(\"black\", \"red\", \"green\", \"blue\", \"purple\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\nL = 3                       # Nível do processo \nk = np.linspace(0, 5, 100)  # Valores para deslocamento\n\n# Comprimento Médio de Sequência\nARL1 = 1 / (1 - (norm.cdf(L - k*np.sqrt(1)) - norm.cdf(-L - k*np.sqrt(1))))\nARL2 = 1 / (1 - (norm.cdf(L - k*np.sqrt(2)) - norm.cdf(-L - k*np.sqrt(2))))\nARL5 = 1 / (1 - (norm.cdf(L - k*np.sqrt(5)) - norm.cdf(-L - k*np.sqrt(5))))\nARL10 = 1 / (1 - (norm.cdf(L - k*np.sqrt(10)) - norm.cdf(-L - k*np.sqrt(10))))\nARL20 = 1 / (1 - (norm.cdf(L - k*np.sqrt(20)) - norm.cdf(-L - k*np.sqrt(20))))\n\n# Gráfico comparativo das Curvas\nplt.plot(k, ARL1, linewidth = .75, color = \"black\", label = 'n = 1')\nplt.plot(k, ARL2, linewidth = .75, color = \"red\", label = 'n = 2')\nplt.plot(k, ARL5, linewidth = .75, color = \"green\", label = 'n = 5')\nplt.plot(k, ARL10, linewidth = .75, color = \"blue\", label = 'n = 10')\nplt.plot(k, ARL20, linewidth = .75, color = \"purple\", label = 'n = 20')\nplt.xlabel('Deslocamento da Média (k)')\nplt.ylabel('Comprimento Médio de Sequência (ARL)')\nplt.title('Comprimento Médio de Sequência vs. Deslocamento da Média')\nplt.ylim(0,400)\n\n\n(0.0, 400.0)\n\n\nCódigo\nplt.legend(title='Amostras', fontsize=9)\nplt.grid(True, alpha=.3)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html#curva-característica-de-operação-cco-cdot-r",
    "href": "C3_CCO_CMS.html#curva-característica-de-operação-cco-cdot-r",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "3.4 Curva Característica de Operação (CCO \\(\\cdot R\\))",
    "text": "3.4 Curva Característica de Operação (CCO \\(\\cdot R\\))\nAo contrário da média, o gráfico de amplitude não apresenta uma distribuição simétrica, mesmo que a amostragem seja feita a partir de uma normalidade. Isso significa dizer que em um nível de operação de \\(3\\sigma\\) o risco \\(\\alpha\\) é diferente de \\(0.0027\\), resultante para a média.\nPara a construção da CCO para o gráfico de amplitude, considera-se um intervalo relativo definido por \\(W=R/\\sigma\\), com suas propriedades de média (\\(E(W)=d_2\\)) e desvio-padrão (\\(\\sigma_W=d_3\\)). Supondo que os valores dentro dos limites de controle tenham um desvio \\(\\sigma_0\\) e a oscilação do gráfico tenha resultado em um novo desvio \\(\\sigma_1\\), o risco \\(\\beta\\) é dado em função da razão dos desvios (\\(\\sigma_1&gt;\\sigma_0 \\Rightarrow \\sigma_1 / \\sigma_0 &gt; 1\\)).\nDesta forma, o risco \\(\\beta\\) para um dado desvio \\(\\sigma\\), em termos de amplitude, de um nível \\(\\sigma_0\\) mudar para \\(\\sigma_1\\), sendo \\(\\sigma_1 = \\lambda\\sigma_0\\), pode ser descrito como\n\\[\\beta = P \\left[ LIC \\leq R \\leq LSC | \\sigma_1 = \\lambda\\sigma_0 \\right]. \\]\nConsiderando os limites inferior e superior de controle como \\(LIE = D_3 \\bar{R} = D_3\\cdot d_2 \\cdot \\sigma_0\\) e \\(LSE = D_4 \\bar{R} = D_4\\cdot d_2 \\cdot \\sigma_0\\), respectivamente, podemos fazer os ajustes, de tal forma que\n\\[\n\\beta = P \\left[ D_3\\cdot d_2 \\cdot \\sigma_0 \\leq R \\leq D_4\\cdot d_2 \\cdot \\sigma_0 | \\sigma_1 = \\lambda\\sigma_0 \\right].\n\\]\nDividindo todos os termos da expressão por \\(\\sigma_1\\), temos que\n\\[\n\\beta = P \\left[ \\dfrac{D_3 d_2}{\\lambda} \\leq W \\leq \\dfrac{D_4 d_2}{\\lambda} \\right],\n\\]\nonde \\(\\lambda\\) representa a razão entre os desvios (\\(\\lambda = \\sigma_1 / \\sigma_0\\)).\nFazendo a aproximação pela distribuição normal da medida relativa \\(W \\sim N(d_2, d_3^2)\\) com os respectivos limites de controle, os termos podem ser trabalhados em termos de função de distribuição cumulativa normal \\(\\Phi(\\cdot)\\). Desta forma, a função \\(\\beta\\) pode ser expressa como \\[ \\beta = \\Phi \\left[\\dfrac{\\dfrac{D_4 d_2}{\\lambda}-d_2}{d_3}\\right] - \\Phi \\left[\\dfrac{\\dfrac{D_3 d_2}{\\lambda}-d_2}{d_3}\\right].\n\\]\nProgressivamente, a construção das CCOs para diferentes números de amostra depende do cruzamento entre o risco \\(\\beta\\) e a distância entre os desvios (\\(\\lambda\\)).\n\nRPython\n\n\n\nCódigo\n# Valores tabelados para d2, d3, D3 e D4\nd2 = c(1.128, 2.326, 3.078, 3.735)\nd3 = c(0.853, 0.864, 0.797, 0.729)\nD3 = c(0,0,0.223, 0.415)\nD4 = c(3.267, 2.115, 1.777, 1.585)\n\n# Diferentes valores para lambda (σ1/σ0)\nlambda = seq(1,6, length.out=100)\n\n# Cálculo de valores para beta\nbetal_2 = pnorm(((D4[1] * d2[1] / lambda) - d2[1]) / d3[1]) - pnorm(((D3[1] * d2[1] / lambda) - d2[1]) / d3[1])\nbetal_5 = pnorm(((D4[2] * d2[2] / lambda) - d2[2]) / d3[2]) - pnorm(((D3[2] * d2[2] / lambda) - d2[2]) / d3[2])\nbetal_10 = pnorm(((D4[3] * d2[3] / lambda) - d2[3]) / d3[3]) - pnorm(((D3[3] * d2[3] / lambda) - d2[3]) / d3[3])\nbetal_20 = pnorm(((D4[4] * d2[4] / lambda) - d2[4]) / d3[4]) - pnorm(((D3[4] * d2[4] / lambda) - d2[4]) / d3[4])\n\n# Gráfico CCO -- R-bar\n# Gráfico comparativo das Curvas\npar(mfrow = c(1, 1))\nplot(lambda, betal_2, type = \"l\", lwd = 1.25, lty=1, \n     col = \"red\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(lambda, betal_5, type = \"l\", lwd = 1.25, lty=1, \n     col = \"green\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(lambda, beta_10, type = \"l\", lwd = 1.25, lty=1, \n     col = \"blue\", axes=F, xlab=\"\",ylab=\"\")\npar (new = TRUE)\nplot(lambda, betal_20, type = \"l\", lwd = 1.25, lty=1, \n     col = \"purple\", axes=T,\n     xlab = expression(\"Razão dos desvios \" (lambda == frac(sigma[1], sigma[0]))),\n     ylab = \"Risco do Consumidor (β)\",\n     main = \"Curva Característica de Operação -- Gráfico R-bar\",\n     ylim = c(0,1))\ngrid()\nlegend(\"topright\", title=\"Amostras\", lwd = 1.25, lty = 1,\n     legend = c(\"n = 2\", \"n = 5\", \"n = 10\", \"n = 20\"),  \n     col = c(\"red\", \"green\", \"blue\", \"purple\"))\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# Valores tabelados para d2, d3, D3 e D4\nd2 = [1.128, 2.326, 3.078, 3.735]\nd3 = [0.853, 0.864, 0.797, 0.729]\nD3 = [0,0,0.223, 0.415]\nD4 = [3.267, 2.115, 1.777, 1.585]\n\n# Diferentes valores para lambda (σ1/σ0)\nlambdas= np.linspace(1, 6, 100) \n\n# Cálculo de valores para beta\nbetal_2 = norm.cdf(((D4[0] * d2[0] / lambdas) - d2[0]) / d3[0]) - norm.cdf(((D3[0] * d2[0] / lambdas) - d2[0]) / d3[0])\nbetal_5 = norm.cdf(((D4[1] * d2[1] / lambdas) - d2[1]) / d3[1]) - norm.cdf(((D3[1] * d2[1] / lambdas) - d2[1]) / d3[1])\nbetal_10 = norm.cdf(((D4[2] * d2[2] / lambdas) - d2[2]) / d3[2]) - norm.cdf(((D3[2] * d2[2] / lambdas) - d2[2]) / d3[2])\nbetal_20 = norm.cdf(((D4[3] * d2[3] / lambdas) - d2[3]) / d3[3]) - norm.cdf(((D3[3] * d2[3] / lambdas) - d2[3]) / d3[3])\n\n# Gráfico CCO -- R-bar\n# Gráfico comparativo das Curvas\nplt.plot(lambdas, betal_2, linewidth = .75, color = \"red\", label = 'n = 2')\nplt.plot(lambdas, betal_5, linewidth = .75, color = \"green\", label = 'n = 5')\nplt.plot(lambdas, betal_10, linewidth = .75, color = \"blue\", label = 'n = 10')\nplt.plot(lambdas, betal_20, linewidth = .75, color = \"purple\", label = 'n = 20')\nplt.xlabel(r'Razão dos desvios $\\lambda = \\sigma_1/\\sigma_0$')\nplt.ylabel('Risco do Consumidor (β)')\nplt.title('Comprimento Médio de Sequência vs. Deslocamento da Média')\nplt.ylim(0,1)\n\n\n(0.0, 1.0)\n\n\nCódigo\nplt.legend(title='Amostras', fontsize=9)\nplt.grid(True, alpha=.3)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nNota-se que a CCO \\(\\cdot R\\) não demonstra bons resultados na detecção de mudanças para valores pequenos de amostra. Isso pode ser observado comparando os casos de \\(n=2\\) e \\(n=20\\); se o desvio padrão do processo dobrar (isto é, \\(\\lambda = \\sigma_1/\\sigma_0 = 2\\)), o primeiro caso tem cerca de 30% de chance em detectar a mudança na amostra subsequente; já no segundo caso, a chance alcança 90%. Por esse motivo, a literatura recomenda o uso do gráfico \\(R\\) para subamostras racionais maiores que 10 (Montgomery 2012).\n\n\n\n\n\n\n\n\n\n\n\nBotter, Denise Aparecida. 2013. «Inspeção de Qualidade». Notas de Aula. https://www.ime.usp.br/~botter/mae532/Inspecao.pdf.\n\n\nCarpinetti, Luiz C. R. 2003. Controle da Qualidade de Processo. 2.ª ed. Universidade de São Paulo.\n\n\nMontgomery, Douglas C. 2012. Statistical Quality Control. 7.ª ed. John Wiley & Sons.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C3_CCO_CMS.html#footnotes",
    "href": "C3_CCO_CMS.html#footnotes",
    "title": "3  Curva Característica da Operação e Compimento Médio da Sequência",
    "section": "",
    "text": "acrônimo em inglês para Average Run Length↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Curva Característica da Operação e Compimento Médio da Sequência</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html",
    "href": "C4_PlotOfAtributes.html",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "",
    "text": "4.1 Introdução",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html#gráficos-de-controle-para-p",
    "href": "C4_PlotOfAtributes.html#gráficos-de-controle-para-p",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "4.2 Gráficos de Controle para \\(p\\)",
    "text": "4.2 Gráficos de Controle para \\(p\\)\nO gráfico \\(p\\) é uma ferramenta destinada ao monitoramento da proporção de unidades defeituosas em um processo produtivo. Esse gráfico é particularmente útil quando a característica de qualidade em estudo pode ser classificada de forma binária, isto é, como “defeituoso” ou “não defeituoso”.\nPara cada amostra coletada é calculada a fração amostral não conforme, definida como a razão entre o número de unidades não conformes (ou seja, unidades defeituosas) na amostra \\(D_i\\) e o tamanho \\(n\\) da amostra, isto é, \\[\\hat{p_i} = \\frac{D_i}{n}\\] Sendo assim, a linha central para o gráfico \\(p\\) é dada por \\(\\hat{p}\\) e os limites para o gráfico (±3\\(\\sigma\\)) são dados por: \\[LIC = \\hat{p} - 3\\sqrt\\frac{\\hat{p}(1 - \\hat{p})}{n}\\] \\[LSC = \\hat{p} + 3\\sqrt\\frac{\\hat{p}(1 - \\hat{p})}{n}\\]\n\n4.2.1 Exemplo\nSelecionadas 19 amostras de tamanho \\(n\\) = 50, temos que:\n\n\nCódigo\ndados &lt;- data.frame(\n  Amostra = 1:19,\n  Di = c(5, 15, 10, 4, 3, 20, 11, 9, 3, 20, 11, 6, 7, 11, 3, 3, 9, 3, 8),\n  pi = c(0.1, 0.3, 0.2, 0.08, 0.06, 0.4, 0.22, 0.18, 0.06, 0.4, 0.22, 0.12, 0.14, 0.22, 0.06, 0.06, 0.18, 0.06, 0.16)\n)\n\n# Proporção média\np_barra &lt;- mean(dados$pi)\np_barra\n\n\n[1] 0.1694737\n\n\nCódigo\n#Cálculo dos limites\nLSC = p_barra + 3*sqrt((p_barra*(1-p_barra))/50)\nLC = p_barra\nLIC = p_barra - 3*sqrt((p_barra*(1-p_barra))/50)\n\ncbind(LSC, LIC, LC)\n\n\n           LSC        LIC        LC\n[1,] 0.3286447 0.01030263 0.1694737\n\n\n\n4.2.1.1 Gráfico\n\n\nCódigo\nplot(dados$pi, type = \"b\", pch = 19, ylim = c(0, max(LSC, max(dados$pi))),\n     col = \"black\",\n     main = \"Gráfico p\",\n     ylab = \"Fração não-conforme\", xlab = \"Amostra\")\n\nabline(h = c(LSC, LC, LIC), col = c(\"red\", \"blue\", \"red\"), \n       lty = c(2,2,2), lwd = 2)\n\n# Legenda\nlegend(\"topright\", legend = c(\"p\", \"p-barra\", \"LIC/LSC\"),\n       col = c(\"black\", \"blue\", \"red\"), lty = c(1,2,2), pch = c(16, NA, NA))\n\n\n\n\n\n\n\n\n\nÉ possível notar no gráfico que as amostras 6 e 10 ultrapassam o limite superior de controle, portanto, estão, estatísticamente, fora de controle.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html#gráficos-de-controle-para-np",
    "href": "C4_PlotOfAtributes.html#gráficos-de-controle-para-np",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "4.3 Gráficos de Controle para \\(np\\)",
    "text": "4.3 Gráficos de Controle para \\(np\\)\nEm determinados processos, os itens produzidos podem apresentar certo número de pequenas não conformidades que não o caracterizem como um item não conforme. No entanto, pequenas não conformidades em excesso pode ser perceptível (e indesejável) ao consumidor.\nO gráfico \\(np\\) tem por objetivo o monitoramento do número de itens defeituosos em uma linha de produção, detectando possíveis problemas no processo quando há extrapolação dos limites de controle.\n\n4.3.1 Gráfico \\(np\\) com Subgrupos Fixos\nQuando o número de amostras coletadas é fixa ao longo do tempo, seus limites de controle e de advertência também o serão. Desta forma, os limites de controle do gráfico \\(p\\) com nível de operação \\(3\\sigma\\) (\\(L=3\\)) são adaptados de tal forma que\n\\[\nLIC = \\left\\{ \\begin{array} n\\bar{p} -3\\sqrt{n\\bar{p}\\cdot(1-\\bar{p})}, \\text{ se } LIC &gt; 0; \\\\ 0, \\text{ caso contrário.} \\end{array} \\right .\n\\]\nrepresenta as condições do limite inferior de controle,\n\\[\nLC = n\\bar{p}\n\\]\nrepresenta o limite central e\n\\[\nLSC = n\\bar{p} + 3 \\sqrt{n\\bar{p}\\cdot(1-\\bar{p})}\n\\]\nrepresenta o limite superior de controle.\nA construção da carta de controle \\(np\\) considera o número de defeitos constados em cada amostra e, baseado nele, é calculado a proporção de defeitos. É possível a determinação de zonas de alerta, onde o processo ainda não sofreu efetivo descontrole, porém é dado um sinal de aviso. O processo deve ser monitorado com maior cautela em casos de tendência ou variações cíclicas e sucessivas.\nPara contextualização o gráfico abaixo representa uma linha de produção com controle realizado feito a partir de \\(n=50\\) itens em cada amostra, com número de defeitos representado por \\(D_i\\).\n\nRPython\n\n\n\n\nCódigo\n# Carregar pacote\nif (!require(glue)) install.packages(\"glue\")\nlibrary(glue)\n\n# Número de não-conformidades\nset.seed(123) # para reprodutibilidade\nD_i &lt;- rbinom(20, 50, 0.1235)\nn &lt;- 50\n\nmedia_p &lt;- mean(D_i / n)\n\n# Valores de interesse\nlc &lt;- n * media_p\nlsc &lt;- n * media_p + 3 * sqrt(n * media_p * (1 - media_p))\nlic &lt;- n * media_p - 3 * sqrt(n * media_p * (1 - media_p))\n\n# Evitar limites negativos\nlic &lt;- max(0, lic)\n\n# Valores de alerta (2σ)\nlsc_a &lt;- n * media_p + 2 * sqrt(n * media_p * (1 - media_p))\nlic_a &lt;- n * media_p - 2 * sqrt(n * media_p * (1 - media_p))\nlic_a &lt;- max(0, lic_a)\n\n# Gráfico np\nplot(1:10, 1:10, type = \"n\", xlab = '', ylab = '',\n     ylim = c(lic * 0.75, lsc * 1.15),\n     xlim = c(1, 20))  # &lt;-- parêntese corrigido\n\n# Zona de alerta\nrect(ybottom = lic_a, ytop = lsc_a, xleft = 0, xright = 20,\n     col = rgb(248/255, 238/255, 153/255, alpha = .30), border = NA)\n\n# Sobreposição da série\npar(new = TRUE)\nplot(D_i, lty = 1, lwd = 1.25, pch = 19, cex = 1.15, type = 'b',\n     ylim = c(lic * 0.75, lsc * 1.15), xlim = c(1, 20),\n     col = '#096CC8', xlab = 'Amostra', ylab = 'Número de não-conformes',\n     main = 'Gráfico np')\naxis(side = 1, at = 1:20, labels = 1:20)\n\n# Linhas de controle\nabline(h = c(lsc, lc, lic),\n       col = c('#CD5C5C', '#8FC6FA', '#CD5C5C'),\n       lty = c(2, 1, 2), lwd = 1.25)\n\n# Textos\ntext(x = c(1, 1, 1, 18),\n     y = c(lic * 1.15, lc * 1.05, lsc * 0.98, lsc_a * 0.98),\n     labels = c(glue(\"LIC = {sprintf('%.4f', lic)}\"),\n                glue(\"LC = {sprintf('%.4f', lc)}\"),\n                glue(\"LSC = {sprintf('%.4f', lsc)}\"),\n                'Zona de Alerta'),\n     col = c('#CD5C5C', '#8FC6FA', '#CD5C5C', '#BCAA01'),\n     cex = .75)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport numpy as np\nimport pandas as pd\nimport random\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Geração de dados\n#random.seed(1236)\nn = 50\n#D_i = list(np.random.normal(loc=15, scale=3, size=25)\n# Número de não-conformidades\nD_i = [12, 14, 14, 18, 10, 16, 11, 19, 12, 17, 20, 20, 18, 14, 19, 14, 16, 15, 13, 14, 15, 14, 20, 14, 17]\np_i = [x / n for x in D_i]\n\n# União de dados em um dataframe\ndados = pd.DataFrame({'Amostra': list(range(1,len(D_i)+1)), 'D_i': D_i, 'p_i': p_i})\n\n# Média das proporções\nmedia_p = dados['p_i'].mean()\n\n# Valores de interesse\nlc = n*media_p\nlsc = n*media_p + 3*np.sqrt(n*media_p*(1 - media_p))\nlic = n*media_p - 3*np.sqrt(n*media_p*(1 - media_p))\n\n# Valores de alerta (2σ)\nlsc_a = n*media_p + 2*np.sqrt(n*media_p*(1 - media_p))\nlic_a = n*media_p - 2*np.sqrt(n*media_p*(1 - media_p))\n\n# Gráfico np\nplt.figure(figsize=(16,6))\nplt.plot(dados['D_i'], color='#096CC8', marker='o', linestyle='-', linewidth=0.9, markersize = 6)\n\n# Plotagem das Linhas dos Limites de Controle\nplt.axhline(y=lc, color='#8FC6FA', linestyle='-', linewidth = 1.1, label='LC')\nplt.axhline(y=lsc, color='#CD5C5C', linestyle='--', label=f'LSC = {lsc:.4f}')\nplt.axhline(y=lic, color='#CD5C5C', linestyle='--', label='LIC')\n\n# Anotação dos Limites de Controle\nplt.annotate(f'LC = {lc:.4f}', xy=(0, lc), xytext=(0, lc*1.05), color='#2471a3')\nplt.annotate(f'LSC= {lsc:.4f}', xy=(0, lsc), xytext=(0, lsc*0.95), color='#CD5C5C')\nplt.annotate(f'LIC = {lic:.4f}', xy=(0, lic), xytext=(0, lic*1.15), color='#CD5C5C')\n\n# Zona de alerta\nplt.axhspan(ymin=lic_a, ymax=lsc_a, alpha=0.3, color ='#F8EE99', label = 'Zona de Alerta')\nplt.annotate('Zona de Alerta', xy=(len(dados)*.9, lsc_a), xytext=(len(dados)*.9, lsc_a*.96), color='#BCAA01')\n\n# Identificação dos eixos\nplt.title('Gráfico de Controle np', fontsize=14)\nplt.xlabel('Amostra')\nplt.ylabel('Número de Não-Conformidades')\nplt.ylim(0, lsc*1.15)\n\n\n(0.0, 29.026536966799764)\n\n\nCódigo\nplt.xticks(ticks=range(len(dados)), labels=dados['Amostra'])\n\n\n([&lt;matplotlib.axis.XTick object at 0x00000263FC0746E0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC081820&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0C4800&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0DC680&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC077950&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0C6A20&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0C4680&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0DD370&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0DDDF0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC081CD0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0DE7B0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0DF230&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0DFBC0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC10C410&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC0816D0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC10CE90&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC10D9A0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC10E420&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC10EEA0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC10D3D0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC10F770&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC124200&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC124C80&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC007FE0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC1248F0&gt;], [Text(0, 0, '1'), Text(1, 0, '2'), Text(2, 0, '3'), Text(3, 0, '4'), Text(4, 0, '5'), Text(5, 0, '6'), Text(6, 0, '7'), Text(7, 0, '8'), Text(8, 0, '9'), Text(9, 0, '10'), Text(10, 0, '11'), Text(11, 0, '12'), Text(12, 0, '13'), Text(13, 0, '14'), Text(14, 0, '15'), Text(15, 0, '16'), Text(16, 0, '17'), Text(17, 0, '18'), Text(18, 0, '19'), Text(19, 0, '20'), Text(20, 0, '21'), Text(21, 0, '22'), Text(22, 0, '23'), Text(23, 0, '24'), Text(24, 0, '25')])\n\n\nCódigo\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nA partir do gráfico acima podemos concluir pela estabilidade do processo, com linha central em \\(LC = 15,44\\), limites de alerta (\\(2\\sigma\\)) em \\(\\{LIA; LSA\\} = \\{5,6395; 25,2405\\}\\) e limites de controle em \\(\\{LIC; LSC\\} = \\{8,9064; 21,97364\\}\\). Nota-se que não há pontos fora da zona de alerta e todos os pontos das \\(m=25\\) amostras retiradas não apresentam sinais de tendência ou ciclidade.\n\n\n4.3.2 Gráfico \\(np\\) com Subgrupos Variáveis\nNa ocorrência de amostras de tamanho variável, sendo \\(n_j = 1,2,\\dots,m\\), os limites de controle se adequam ao tamanho amostral individual. Desta forma, os limites para um processo em \\(3\\sigma\\) são expressos por\n\\[\nLIC = \\left\\{ \\begin{array} nn_j\\bar{p} -3\\sqrt{n_j\\bar{p}\\cdot(1-\\bar{p})}, \\text{ \\hspace{.5cm} se \\hspace{.25cm}} LIC &gt; 0; \\\\ 0, \\text{ \\hspace{5.1cm} caso contrário.} \\end{array} \\right .\n\\]\nrepresentando as condições do limite inferior de controle, \\[\nLC = n_j\\bar{p}\n\\] representa o limite central e \\[\nLSC = n_j\\bar{p} + 3 \\sqrt{n_j\\bar{p}\\cdot(1-\\bar{p})}\n\\] representa o limite superior de controle.\nA construção do gráfico considera o número variável do tamanho amostral (\\(n\\)), gerando, portanto, limites de controle e de alerta flutuantes. A carta abaixo considerou dimensões de amostra entre 48 e 52 unidades em cada retirada.\n\nRPython\n\n\n\n\nCódigo\nrequire(glue)\nset.seed(1236)\nn_j = sample(48:52, 25, replace=TRUE)       # Subgrupos variáveis\nD_i = round(rnorm(n=25, mean=15, sd=3),0)\np_i = D_i / n_j\n\n# União de dados em um dataframe\ndados = data.frame(Amostra=1:length(D_i), D_i=D_i, n_j=n_j, p_i=p_i)\n\n# Média das proporções\nmedia_p = mean(dados$p_i)\n\n# Valores de interesse\nlc = n_j*media_p\nlsc = n_j*media_p + 3*sqrt(n_j*media_p*(1 - media_p))\nlic = n_j*media_p - 3*sqrt(n_j*media_p*(1 - media_p))\n\n# Valores de alerta (2σ)\nlsc_a = n_j*media_p + 2*sqrt(n_j*media_p*(1 - media_p))\nlic_a = n_j*media_p - 2*sqrt(n_j*media_p*(1 - media_p))\n\n# Gráfico np\npar(mfrow = c(1, 1))\nplot(dados$D_i, lty = 1, lwd=1.25, pch=19, cex=1.15, type='b',\n    xlim = c(1, nrow(dados)), ylim = c(min(lic)*0.75,max(lsc)*1.1),\n    col='#096CC8', xlab='Amostra', ylab='Número de não-conformes',\n    main = 'Gráfico np')\naxis(side = 1, at = dados$Amostra, labels=dados$Amostra)\n\n# Plotagem das Linhas dos Limites de Controle\nlines(x=dados$Amostra, y = lc, col = '#8FC6FA', lty=1, lwd=1.25)\nlines(x=dados$Amostra, y = lsc, col= '#CD5C5C', lty = 2, lwd = 1.25)\nlines(x=dados$Amostra, y = lic, col='#CD5C5C', lty = 2, lwd = 1.25)\n\n# Plotagem das Linhas de Alerta\nlines(x=dados$Amostra, y = lsc_a, col= '#BCAA01', lty = 2, lwd = 1.5)\nlines(x=dados$Amostra, y = lic_a, col= '#BCAA01', lty = 2, lwd = 1.5)\n\n# Configuração das legendas\nlegend(x='topleft',legend = c(\"LIC\", \"LC\", \"LSC\"), col=c('#CD5C5C','#8FC6FA','#CD5C5C'), \n    lty=c(2,1,2), lwd=1.25, cex=.75, horiz=TRUE, title='Limites de Controle')\nlegend(x='topright', legend = c(\"LIA\", \"LSA\"), col='#BCAA01', \n    lty=2, lwd=1.5, cex=.75, horiz=TRUE, title='Zona de Alerta (2σ)')\n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\nimport warnings\nwarnings.filterwarnings('ignore')\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nn_j = [51,48,48,50,48,50,51,50,49,50,51,52,52,50,50,48,49,48,48,52,48,52,49,50,49]\nD_i = [12,14,14,18,10,16,11,19,12,17,20,20,18,14,19,14,16,15,13,14,15,14,20,14,17]\np_i = [x / y for x, y in zip(D_i, n_j)]\n\n# União de dados em um dataframe\ndados = pd.DataFrame({'Amostra': list(range(1,len(D_i)+1)), 'D_i': D_i, 'n_j':n_j, 'p_i': p_i})\n\n# Média das proporções\nmedia_p = dados['p_i'].mean().round(4)\n\n# Valores de interesse\nlic = dados['n_j']*media_p - 3*np.sqrt(dados['n_j']*media_p*(1 - media_p))\nlc = dados['n_j']*media_p\nlsc = dados['n_j']*media_p + 3*np.sqrt(dados['n_j']*media_p*(1 - media_p))\n\n\n# Valores de alerta (2σ)\nlsc_a = dados['n_j']*media_p + 2*np.sqrt(dados['n_j']*media_p*(1 - media_p))\nlic_a = dados['n_j']*media_p - 2*np.sqrt(dados['n_j']*media_p*(1 - media_p))\n\n# Gráfico np\nplt.figure(figsize=(16,6))\nplt.plot(dados['D_i'], color='#096CC8', marker='o', linestyle='-', linewidth=0.9, markersize = 6)\n\n# Plotagem das Linhas dos Limites de Controle\nplt.plot(lc, color='#8FC6FA', linestyle='-', linewidth = 1.1, label='LC')\nplt.plot(lsc, color='#CD5C5C', linestyle='--', label=f'LSC')\nplt.plot(lic, color='#CD5C5C', linestyle='--', label='LIC')\n\n# Plotagem das Linhas de Alerta\nplt.plot(lsc_a, color='#BCAA01', linestyle='--', label=f'LSA')\nplt.plot(lic_a, color='#BCAA01', linestyle='--', label=f'LIA')\nplt.legend(title='Limites de Controle')\n\nplt.ylim([0, np.max(lsc)*1.15])\n\n\n(0.0, 30.065050709186004)\n\n\nCódigo\nplt.xticks(ticks=range(len(dados)), labels=dados['Amostra'])\n\n\n([&lt;matplotlib.axis.XTick object at 0x00000263FC0C66F0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC7F1A90&gt;, &lt;matplotlib.axis.XTick object at 0x00000263E8E9E0C0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC89AFF0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC841D60&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC899AF0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC898F20&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC89BCE0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8CC770&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC899C70&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8CCB90&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8CD5E0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8CE090&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8CEB70&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8CDCA0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8CF440&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8CFDA0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8F07A0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8F1160&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC820C80&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8F1A30&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8F2360&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8F2DE0&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8F3860&gt;, &lt;matplotlib.axis.XTick object at 0x00000263FC8F1D30&gt;], [Text(0, 0, '1'), Text(1, 0, '2'), Text(2, 0, '3'), Text(3, 0, '4'), Text(4, 0, '5'), Text(5, 0, '6'), Text(6, 0, '7'), Text(7, 0, '8'), Text(8, 0, '9'), Text(9, 0, '10'), Text(10, 0, '11'), Text(11, 0, '12'), Text(12, 0, '13'), Text(13, 0, '14'), Text(14, 0, '15'), Text(15, 0, '16'), Text(16, 0, '17'), Text(17, 0, '18'), Text(18, 0, '19'), Text(19, 0, '20'), Text(20, 0, '21'), Text(21, 0, '22'), Text(22, 0, '23'), Text(23, 0, '24'), Text(24, 0, '25')])\n\n\nCódigo\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nQuando trabalhamos com limites variáveis, há uma sensibilidade maior em detectar pontos de atenção e pontos fora de controle, dado que amostras menores tendem a indicar proporcionalmente mais defeitos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html#gráficos-de-controle-para-c",
    "href": "C4_PlotOfAtributes.html#gráficos-de-controle-para-c",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "4.4 Gráficos de Controle para \\(c\\)",
    "text": "4.4 Gráficos de Controle para \\(c\\)\nSegundo Montgomery, um item pode conter mais de um tipo de defeito de fabricação (não-conformidades) dependendo da sua natureza e severidade. Há casos em que quando tem-se como interesse o monitoramento dos defeitos resultantes do processo, é preferível trabalhar com o número de defeitos ao invés da fração defeituosa, como por exemplo o número de defeitos em um equipamento eletrônico.\nO gráfico de controle do número de defeitos (gráfico C) mede o número de defeitos em uma amostra de tamanho constante ou uma",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C4_PlotOfAtributes.html#gráficos-de-controle-para-u",
    "href": "C4_PlotOfAtributes.html#gráficos-de-controle-para-u",
    "title": "4  Gráficos de Controle para Atributos",
    "section": "4.5 Gráficos de Controle para \\(u\\)",
    "text": "4.5 Gráficos de Controle para \\(u\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Gráficos de Controle para Atributos</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html",
    "href": "C5_IndCapacity.html",
    "title": "5  Índice de Capacidade",
    "section": "",
    "text": "5.1 Limites de Especificação (definidos em projeto)\nOs índices de capacidade do processo são parâmetros adimensionais que indiretamente medem o quanto o processo consegue atender às especificações. Eles comparam a dispersão do processo com os limites de especificação.\nLimite inferior (LIE): valor mínimo aceitável Limite superior (LSE): valor máximo aceitável",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índice de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#importante",
    "href": "C5_IndCapacity.html#importante",
    "title": "5  Índice de Capacidade",
    "section": "5.2 Importante:",
    "text": "5.2 Importante:\n&gt; os índices de capacidade só têm sentido se os dados analisados forem provenientes de um processo dentro de controle. Eles são parâmetros (analisados e definidos);\n&gt; evidenciada a condição de controle o estudo de capacidade pode ser conduzido;\n&gt; eficiência - entendido como baixo nível de não-conformidades. **&gt;",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índice de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#índice-cp---capacidade-potencial",
    "href": "C5_IndCapacity.html#índice-cp---capacidade-potencial",
    "title": "5  Índice de Capacidade",
    "section": "5.3 Índice Cp - Capacidade Potencial**",
    "text": "5.3 Índice Cp - Capacidade Potencial**\nMede a largura do intervalo de especificação em relação à variabilidade do processo.\nNão considera o centramento.\nQuanto maior o Cp, melhor\nNa prática, o desvio padrão é desconhecido e deve ser substituído por uma estimativa de 6-sigma.\nCp = (LSE- LIE)/ 6*SIGMA …# melhorar (fazer Cp como ESTIMADOR)\nOs limites expresam a tolerância natural doprocesso.\nNote que o índice Cp relaciona a tolerância especificada com a tolerância natural do processo. Assim,\n\nCp &lt; 1, TN é maior que TE (preocupante)\nCp = 1, TN é igual TE (precisa melhorar)\nCp &gt; 1, TN é menor que TE (desejável)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índice de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#porcentagem-de-especificação",
    "href": "C5_IndCapacity.html#porcentagem-de-especificação",
    "title": "5  Índice de Capacidade",
    "section": "5.4 Porcentagem de Especificação:",
    "text": "5.4 Porcentagem de Especificação:\nA percentagem utilizada mede o quanto da faixa de tolerância está sendo ocupada pela variabilidade do processo.\nPesp = (1/Cp)*100\n&gt;Valores baixos indicam boa folga para atender especificações. &gt;Valores altos indicam risco de não conformidade.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índice de Capacidade</span>"
    ]
  },
  {
    "objectID": "C5_IndCapacity.html#exemplos",
    "href": "C5_IndCapacity.html#exemplos",
    "title": "5  Índice de Capacidade",
    "section": "5.5 Exemplos:",
    "text": "5.5 Exemplos:\n\n5.5.1 1) Um processo tem: LIE = 45, LSE = 55 e σ= 1,5. Calcule Cp.\n\n\nCódigo\nLIE &lt;- 45\nLSE &lt;- 55\ndesvio &lt;- 1.5 \nCp &lt;- (LSE - LIE) / (6 * desvio)\nCp\n\n\n[1] 1.111111\n\n\n\n\n5.5.2 2) Sabendo que LIE = 12,0, LSE = 12,6, x_bar = 12,25 e σ = 0,06,calcule Cpu, Cpl e Cpk\n\n\nCódigo\nLIE =12.0\nLSE = 12.6\nmedia = 12.25\ndesvio = 0.06\n\nCpu &lt;- (LSE - media) / (3 * desvio)\nCpu\n\n\n[1] 1.944444\n\n\nCódigo\nCpl &lt;- (media - LIE) / (3 * desvio)\nCpl\n\n\n[1] 1.388889\n\n\nCódigo\nCpk &lt;- min(Cpu, Cpl)\nCpk\n\n\n[1] 1.388889\n\n\n\n\n5.5.3 3) Um processo apresenta Cp = 1,40. Qual é a percentagem da especificação utilizada?\n\n\nCódigo\nCp_3 = 1.40\n\nPesp = (1/Cp_3)*100   #R: 71,43% de toda a variabilidade permitida  (LSE - LIE)\nPesp   #\"Percentagem de Especificação utilizada = 71.43%\n\n\n[1] 71.42857\n\n\n\n\n5.5.4 4) Um processo de envase tem LIE = 495 mL, LSE = 505 mL, x¯ = 503 mL e σ = 2 mL. Calcule Cpu, Cpl e Cpk e interprete se o processo é capaz.\n\n\nCódigo\nLIE = 495\nLSE = 505\nmedia = 503\ndesvio = 2\n\nCpu &lt;- (LSE - media) / (3*desvio)\nCpu\n\n\n[1] 0.3333333\n\n\nCódigo\nCpl &lt;- (media - LIE) / (3*desvio)\nCpl\n\n\n[1] 1.333333\n\n\nCódigo\nCpk &lt;- min(Cpu, Cpl)        \nCpk  \n\n\n[1] 0.3333333\n\n\nInterpretação: Como Cpk &lt; 1.0 o processo não é capaz.\n\n\n5.5.5 5) Considere LIE = 97, LSE = 103, n = 30 e S = 0,8. Teste, ao nível de significância de 5%, se o processo é capaz para Cp = 1,33.\n\n\nCódigo\nLIE = 97\nLSE = 103\nn = 30\ns = 0.8\nCp = 1.33\n\n# Calculo de Sig0 (desvio)\ndesvio_z = (LSE - LIE)/(6*Cp)\ndesvio_z\n\n\n[1] 0.7518797\n\n\nCódigo\n# Estataistica de teste\nqui_quad = ((n-1)*s^2)/(desvio_z)^2\nqui_quad\n\n\n[1] 32.83078\n\n\nCódigo\n# Análise: Valor crítico para alfa = 0.05, gl = 29\n  # qui_quad_Crit = 17.71\n  # Como qui_quad &gt; qui_quad_Crit, não se rejeita H0,ou seja, o processo não é capaz\n  \n\n# Nota: Hipoteses \n    #   H0: Cp = Cp0    x   H1: Cp # Cp0   \n\n\nInterpretação: Como 32.83 &gt; 17.71 ao nível de significancia de 0.05, não rejeitamos H0. Ou seja, o processo não é capaz.\n\n\n5.5.6 Uma indústria alimentícia deseja verificar a capacidade do processo de empacotamento de açúcar (peso em gramas). Dados coletados (n = 10, uma medida por pacote):\nDados: 1005, 1008, 1004, 1007, 1006, 1009, 1005, 1004, 1008, 1006.\nEspecificações: LIE = 1000 g, LSE = 1010 g.\na) Calcular Cp, Cpu, Cpl e Cpk.\n\n\nCódigo\ndados_7 = c(1005, 1008, 1004, 1007, 1006, 1009, 1005, 1004, 1008, 1006)\nmedia =mean(dados_7)\ndesvio = sd(dados_7)\n\nLIE = 1000\nLSE = 1010\n\n \nCp &lt;- (LSE - LIE) / (6 * desvio)\nCp\n\n\n[1] 0.9517337\n\n\nCódigo\nCpu &lt;- (LSE - media) / (3*desvio)\nCpu\n\n\n[1] 0.7233176\n\n\nCódigo\nCpl &lt;- (media - LIE) / (3*desvio)\nCpl\n\n\n[1] 1.18015\n\n\nCódigo\nCpk &lt;- min(Cpu, Cpl)        \nCpk \n\n\n[1] 0.7233176\n\n\nb) Determinar a percentagem da especificação utilizada. —– ver 3a)\nc) Construir um histograma com os limites de especificação\n\n\nCódigo\nlibrary(ggplot2)\nlibrary(qcc)\ndados_7\n\n\n [1] 1005 1008 1004 1007 1006 1009 1005 1004 1008 1006\n\n\nCódigo\nLSL &lt;- 1000\nUSL &lt;- 1001 \nlibrary(ggplot2)\nlibrary(dplyr)\n\ndad = data.frame(valor = rnorm(100, mean = 50, sd = 10))\n\n\n# Defina seus limites de especificação\nlimite_inferior &lt;- 30\nlimite_superior &lt;- 70\n\n# Crie o histograma com os limites de especificação\nggplot(dad, aes(x = valor)) +\n  geom_histogram(fill = \"skyblue\", color = \"black\", binwidth = 5) + # Crie o histograma\n  geom_vline(xintercept = limite_inferior, color = \"red\", linetype = \"dashed\", size = 1) + # Linha do limite inferior\n  geom_vline(xintercept = limite_superior, color = \"red\", linetype = \"dashed\", size = 1) + # Linha do limite superior\n  labs(title = \"Histograma com Limites de Especificação\",\n       x = \"Valores\",\n       y = \"Frequência\") +\n  theme_minimal() # Um tema simples para o gráfico",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Índice de Capacidade</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referências",
    "section": "",
    "text": "Botter, Denise Aparecida. 2013. “Inspeção de Qualidade.”\nNotas de Aula. https://www.ime.usp.br/~botter/mae532/Inspecao.pdf.\n\n\nCarpinetti, Luiz C. R. 2003. Controle Da Qualidade de Processo.\n2nd ed. Universidade de São Paulo.\n\n\nMontgomery, Douglas C. 2012. Statistical Quality\nControl. 7th ed. John Wiley & Sons.",
    "crumbs": [
      "Referências"
    ]
  }
]